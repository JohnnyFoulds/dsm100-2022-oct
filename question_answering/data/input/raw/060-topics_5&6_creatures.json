{
  "course": "DSM100-2022-OCT",
  "topic": "Topics 5&6: Creatures",
  "title": "Lecture: Test driven approach",
  "url": "https://learn.london.ac.uk/mod/page/view.php?id=96276&forceview=1",
  "transcript": "[MUSIC]In this video, I'm going to give a bit of technical contextfor the programming approach I will be usingto develop the code of the next few videos.Now, the approach I want to use is the test-driven development approach.I'll just say that if you have studied my modules before,so if you've already seen me talking about test-driven development,there's nothing new here.You've already seen it, you can probably just skip through this video.If you haven't seen test-driven development before,then this is what we're going to be talking about.First of all, I'm going to say what test-driven development is.I'm going to give you a nice detailed description of it.Then we're going to talk about the three laws of test-driven development,which gives us a good flavor of what the approach is.Then I'm going to quickly show you how to do it in Pythonusing the unit test library.Okay.Here's a definition of test-driven development.Test-driven development is a practiceadvocated by agile software development methodologies.Agile software, so it comes from agile software,and in which tests are written in advance of source-code development.Tests are written in advance of source-code development,that's important.The idea is that you write the tests first,and then you write the code to pass the tests.The tests are intended to initially failin the absence of any substantial implementation.As we say, you haven't implemented it,you write the test and then you have some really bare bones implementationthat's going to fail the test.Then you write enough implementation to pass the test.The tests effectively constitute a specification of the functionalityand behavior of the software code.This is good news, people,if you haven't done test-driven development before.If you've done any software engineering,you've seen all the different ways of writing specifications,requirements, documents, user stories, all this, blah, blah, blah.All that stuff's great,but the great thing about test-driven development is you can throw it all away.Don't quote me on that,and you can just make sure that your software passes the tests.If your software passes the test, then it's good enough.If the tests aren't sufficient to test all the requirements,then you need better tests and you need to write those,but yes, that's the kind of idea.It's never that simple, but that's the idea is thatby writing these tests,you're saying exactly what the code should do.You don't need a separate document that specifies what the code is supposed to do.You just say, \"Well, here's the test.If it passes these set of tests, then it's working.\"That's really good.Let's move on.These are the three laws of test-driven development.You may not write production code unless you've first written a failing unit test.What does that mean?The idea is, well, I probably should point outthat what we mean by tests are, we write code which tests other code.The test itself is some code,but the actual code itself, that's the program,we're testing that with our test, but we write the test code first.You may not write any production code until you've written a test that fails.Then the next rule is you may not write more of a unit testthan is sufficient to fail.You don't go and write hundreds of testsand then write the code to pass the tests.You write one test at a time.You only write a complicated enough test to make your code fail the test.It's an iterated thing.Then you may not write more production codethan is sufficient to make the failing unit test pass.In the same way thatwe only write the minimal test to make the thing fail,and then we only write the minimum production code to pass the test.Then we write another test.The idea is you don't write these really elaborate tests,you don't write really elaborate code to pass the tests unless you need to.It's all about writing the bare minimum of code each timeand you iterate.It's an iterated cycle and it's supposed to be really quick.You're supposed to quickly write a test then write the code to pass a test.That's the approach I'm going to be using.Now, in the next bit of this video, I just want to show youhow to quickly write unit tests using Pythonand the unit test framework.Here's an example.I'm going to jump into my code editor and code this up, actually.I'm going to create a new file, save it as test.py.The first thing we do is we import the unit test module.That gives us access to built-in unit testing functionality in Python.The next thing we need to do is implement a classand it can be called whatever you want,but the important thing is that it extends on unittest.TestCase.We're basically extending on this class.If you haven't done object-oriented programming in Python before,let's do some object-oriented programming, it's not too hard.For our purposes here,we're just going to be basically thinking of a namespace,so really the class is a way to store a bunch of functions in a neat way.What we're defining here is a class which contains a bunch of tests,so you'll see how that gets built up.The next thing I need to do is write a test.What I do is I write a function, which starts with the word test.Let's call it test mean.It takes as an argument self,because this is going to get past an instanceof the object itself when it runs,which is object-oriented programming in Python.This is not a Python programming course,so I'm not going to go into loads of detail on that.What I want to do is I'm going to import numpy,and I'm going to use some tests on numpy as an example.When we call mean in numpy,we expect to get the mean of some values, don't we?If I was to call numpy.mean on one--Sorry about the thing that keeps popping up in the way.If I was going to call numpy.mean on 1, 2, 3.I don't like all these pop ups, I should disable them.I'll disable them so they don't keep annoying us.Anyway, so numpy.mean 1, 2, 3,you can probably guess the result of that should be two, right?What we do in order to test if that function was correct,we do self assert equal.This is why we need self as an argument.Unittest.TestCase class, which we've extended,gives us a whole bunch of functions for doing tests on results.We want to test that the result of calling np.mean is in fact two.We want mean to equal two.That says, check the result of calling np.mean on 1, 2, 3 was two.That's my first test.Then I just run it by doing unittest.main,and that would just run this thing.I press Save, and I'm going to run this straightaway in my editor here.There's a result, so you can see it basically saidran one test and how long it took.Then it says okay, which means the test was passed.Let's maybe write a failing test.Imagine I've got another function,another test called testcall it test mean2.This time, I'm going to see np,just to show you a failing test, although I haven't got some failing code.Let's doing, 1, 1, 1,and I'm going to go self.assertEqual.Mean is going to equal two, so that's wrong.I've deliberately created a wrong testjust to show you what happens when it fails a test.That is going to fail, obviously, because I've asked it to make sure thatI get a one back, but in fact--I'm sorry, I've asked it to make sure I get a two back,but in fact, I'm going to get one back.It should produce an error message to that effect.There's an assertion error, so the assertion failed.I got a one and you asked for a two, it says it's not equal to two.One, you ran two tests and there was one failure.That's just showing you how to do that.Your test-driven cycle would be, you write a testand then you go off to your code and you fix the code so it passes the testthen you come back, you run the test again.That's what we're going to be doing.Okay.In this video, we have just beenseeing how test-driven development works.Like I said at the beginning,you should have covered this already,if you've done my other videos in various courses.You may be hitting this for the first time,in which case, don't worry if this is all new to you.There's plenty of documentation online about unit tests,but also, as I work through, I'm going to be explaining my test.I'm going to be writing loads of testsand you'll see exactly how it's done as we go,and hopefully, it won't be too problematic.It's definitely worth learningbecause it's a very good way of developing algorithms,because you can verify thatthe algorithm is doing what it's supposed to do at every step.In this video, I've just been introducing the test-driven methodologythat I'm going to be using to develop the codeover the next few videos."
}