{
  "course": "DSM100-2022-OCT",
  "topic": "Topics 5&6: Creatures",
  "title": "Lecture: Creating things in the world",
  "url": "https://learn.london.ac.uk/mod/page/view.php?id=96247&forceview=1",
  "transcript": "[music]In this video,I'm going to show you how to put objects  into your PyBullet physics world.In summary,I'm going to start by explaining  the differencebetween collision and visual shapes,and then we're going to see  how we can put a floor into our world,and we're going to see  how we can drop a cube on the floorand then run the physics simulation  in real-time.Okay, so let's start out  by considering this.In PyBullet,we separate the look of a shape  from the way it behaves when colliding.What does that mean?Let me explain  with the use of a diagram over here.If I've got two spaceships like this,and I've got another one down here,  maybe an attacking spaceship.What I want to do is I want to work out,  is there a collision here?Imagine I'm trying to work out  if these two things have collided,I might need to say,  \"Have they collided there?\"The computational complexityof basically comparing each  of their coordinates to each otheror whatever it is we're going to do,we'd have to look at--if we're fully computing all  of the visual coordinates that we can seeand whether they've clashedwith all of the other visual coordinates  of the other spaceshipis quite computationally expensive.It's not that difficult  to program in a way,but it's just that it takes  a lot of computation timeand that might mean our simulation or our game runs too slowly.What we typically do is we simplify itand we have basically a bounding box,which is the sort of collision box.If the two collision boxes,  those two bounding boxes overlap,then that means there's been a collision  and then we do the appropriate thing.That makes the physics engineor the computation of when  the collision has occurred much easier.We do the same thing in PyBullet.Even in PyBullet,which is a really complicated  full-on physics engine,you can separately specify  the visual look,so how things look,the geometry of how something looks  from the geometry of how it collides,in order to have control  over how much computational poweryou're going to put  into your collision computations.That's just an important concept  that you're going to need to understandwhat we're going to do  in the next few steps.The next step is to put a floor  into the environment.Let's start up the environment  first of allby doing i.pythonand doing importing pybullet as p,and then we do p.connect  and (p.GUI) to get a real-time GUI.There's my environment.I want to put a floor in.Now, the floor  is just going to be a flat lane,which sits on the surfaceand other objects can then fall onto it  and sit on it.How do I do that?Well, first of all,I need to specify the geometry for a shape  before I can create the shape.I'm going to use  that geometry twice, right?Once for the collision  and once for the visual.Let's do  floor_shape = p.createCollisionShape().The collision shape,I'm going to use  one of the built-in prefixed geometries,which is GEOM_PLANE.That creates basically a 2D planewhich I can then place  into the environment.How do I place into the environment?Well, I do floor = p.createMultiBody.Now it is a multi-bodyin that it can have  multiple geometries combinedand connected together in different ways.We'll see more about that later  when we get into URDF.For now, it's a multi-body  that only consists of one shape basically.It's going to have the floor shape  for its visual geometry,and it's going to have the floor shape  for its collision geometry as well.Then hopefully what we'll see  is the environment now has a floor.You can see it's created this nice  checkerboard kitchen floor for me,and I can stick my robots onto that,and they won't fall through,  into the abyss anymore.Okay, great.That's the first step.Now, the next step  is I'm going to create an object,and this time I'm going to use  a different geometry.I need to create a new geometry  for the object I'm going to create.I'm going to use geometry box,which allows me to specify a box  instead of a plane,which is what I used before.Let's do that.I'm going to do  box-geom = or box_shape, maybe= p.createCollisionShape.I'm going to use collision shape again.This time it's going to be (p.GEOM_BOX, ).Because it's a box,  I need to specify the proportions of it,of the width, the height, and the depth.I'm going to do that with an array.It is half-sorry, just reminding myself,halfExtends=,  and then it's going to be [1, 1, 1]which will give me a cubebecause it's going  to have the same proportions.I've got my box shape.Now, as you might imagine,  I now want to create my box.Let's get that out there.I'm going to get out the way  so we can see it.To create my box,  I'm going to basically do box = p.create.Can you remember the name of the function?MultiBody.I'm going to pass it box_shapefor both the visual shape  and the collision shape like that.Then hopefully I've got a box. Great.I've got a box,but it doesn't look like a cube  that is not a cube.That is a cuboid.  It's a sort of rectangular cube.What's the problem?You can see that half of it  is sitting below the plane.The reason is it creates the objects  by default at the origin point (0, 0, 0).The center of the object that you create  is at 0, 0, 0 in the origin.It's basically just being bisected  by the plane.That's okay.  We'll deal with that in a minute.The next step is to add gravity.I do p.setGravityand you set gravity by passing an X value,  a Z value, and then a Y value,which is a little bit unusual.It's normally X, Y, Z,but this is X, Z, Y.X is left and right,Z is backwards and forwards  and Y is obviously up and down.Because I want it to fall down,  I do -10 on the Yso (0, 0, -10).I've set the gravity,but still, nothing seems to be happening.Well, kind of is sitting floor so maybe,but the final step is to tell  the simulation to start running.I need to do set real-time mode.p.setRealTimeSimulationand pass it at one and I press enter.Oh, did you see that?The box lifted up into the air,  oh, and it's falling down again.Now it seems to be  balanced perfectly like that,which is interesting.What happened is the physics engine  threw the box up in the airand then it fell down because it threw it perfectly up  in the air.It landed perfectly balanced.Then because of little variations  in the physics engine,a bit of noise in the physics engine  eventually it toppled over.There we go.  That's the physics engine running.Now one question is,  why did the box fly up in the air?Why do you think?Well, actually the plane  was interacting with the boxso the box was cutting through the plane.The physics engine didn't like that.It doesn't like things  going over each otherthat shouldn't be allowed to.It gradually pushed the box up  and then shoved it up in the airand then gravity  started acting on the box,pulled it down,and the box then landed.As I said,because it went up perfectly straight, it landed perfectly straight,but then because of a little bit of noise  in the engineto stop things like that from happening,it eventually toppled over.That is it.In summary,what we've just been doingis putting objects into our PyBullet  physics engine environment.We started outby just thinking about the difference  between collision shapesand visual shapes,just to make that really clearwhile we were passing into geometries  when we went to create the floor.We created a plane geometry for the floor,put that there.and you saw it created a texture for me,which was quite neat  and it put some lights on,and then we put a cube  into the environmentwhich dropped down and fell onto the floor eventuallyonce we turned the gravity on  and started the simulation.In this video,we've been looking at how we can create  objects in the PyBullet world."
}