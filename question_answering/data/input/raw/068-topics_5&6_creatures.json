{
  "course": "DSM100-2022-OCT",
  "topic": "Topics 5&6: Creatures",
  "title": "Lecture: Fixing positions of children",
  "url": "https://learn.london.ac.uk/mod/page/view.php?id=96299&forceview=1",
  "transcript": "[music]In this video, I'm going to identifya problem with the geometryof our robot that might not have been apparentwhen we're generating random robots.In summary, I'm going to talk about the problem,which is overlapping parts,and then I'm going to give you a quick solution,which is a bit hacky, but it works,so I'm happy with it for nowand we'll proceed from there.Here's the problem,actually, I'm going to draw this one out.Say we have a flat link structurelike this, where we have A,and we have B,and basically, B has got a recurrence of two,so it's connecting twice to A,so we end up with two B. When we expand that graph,as you'd expect, we end up with an A,connected to two Bs,like that.That's great, that's all very well,but the problem with that is,it's not how it's reflectedin the geometry of the robot.In an abstract sense,the graph does look like this,but in terms of the physical geometry that will generate,it doesn't actually look like this.This is what it does look like,it will actually be like this.We'll have our A,and we'll have our B,we'll have A and Bwe'll connect that,and then we'll just create another Bin exactly the same place,and we'll stick it there.It'll be correct, there will be two Bs,and there will be one A,but the Bs will be in exactly the same placebecause we're not taking account of the factthat in our geometry generation,that there might be more than one childor sibling, if you like.How are we going to solve it?We're going to go into our codeand we're going tobasically implement some stuff.Before we do,I want to show you what it looks like, what I mean, exactly.I've got some test code hereif I can just dig through my errors.Here we go.This is my test code.What it does is it justhard codes a couple of links,so we got your URDF link A and B,and then B connects to A with a recurrence of two.I've set it up so that it's really obvious.It should have a rotation of 0.75 radianson the X-axis,I think that's X-axis,and it should have a length of 1.0.The default length will be 0.1because it's a default parameteron the URDF link.The B link should be really big.What we want to see is our two big long links running.If I run that code,and render out the URDF file,and then I fire it up in iPython,so I do run starter,and push that over there,and then-- get out of the way,and then we do C = p.load.Yes, there we go.I'll do p.setRealTimesSimulation(1).There it is.You can see pretty obviously,that it doesn't look like it has two links, does it?You can just see that one little blob,and then the two little--It looks like one bar sitting next to it.Let me drag it.Let me see if I can pull it a bit closer.There we go.That's that, that's the problem,is you've got this one blob, and then one bar.One is this sort of--I want the bars to fan outbecause there's two of them,so that they fan out like that.Let's see if we can convince it to do thatand I'll show you how I'm going to do it.I'm going to go back into my genome class.First thing I need to do,is I need to go into the URDF class actuallyand tell itthat it needs a new parameter.In the constructor of URDF,I'm going to put a parameterwhich is going to be calledsibling index,self.sibling_index = 1.It's going to default to one,but that just allows me to know that it's there.It's going to have a propertyand then how am I going to use that property?The higher that number is,the more rotation I'm going to give myself,but proportional to what the rotation is encoded in the genome,so it's still parameterized for evolution,but it's still going to be proportional.To do that, I'm going to whiz down hereinto the nasty XML code.I'm looking at this line here,which is where I calculate the origin tag,which dictateswhere the thing is relative to the parent.I'm going to pull this value out and calculate it separately.I'm going to do rpy1 =self.joint_origin_rpy_1* self.sibling_ind.That line there means thatthe rotation will increase dependingon which of the siblings I am so if I've got multiple siblings,it should increase.I'll just put that parameter in hereinstead of the original one, (rpy1).The next step is I need to assigna correct sibling indexto the URDF linksas I'm generating this.I'll only knowwhich sibling of the siblings it is,I only know that when I do the expanding links code.That is in expandLinks,which is up here somewhere.Where is it?  There we go.ExpandLinks, there it is.It's this function here,I need to update this.This is the one that iterates overthe children and iterates through the recursionand knows which sibling it is.What I'm going to do is do something simple.I'm going to do sibling_ind = 1and then I'm going to dosibling_ind = +1.That way, it's going to increase every timewe recreate a new sibling.I just need to thenassign it to the copy.C_copy remember, is the URDF linkthat I'm generatingas I go through the expanded thingand it's sibling_index = sibling_ind.That means they will now have a proper sibling indexto rotate themselves.That should be more or less it.I've written the bit of the codethat generates the origin tag,so it takes account of which sibling it is,and I've updated this codeso that it correctly assigns a siblingor at least it assigns an increasing sibling number to that.Hopefully, I can now run thisand generate a new--no crash is good.Now I can generate a new URDF file,which I have, and have a look at it.Let's go back over here again,and load a new URDF file.I'll get out of the way so you can see it.Hopefully,now you can seethat the two sticksthat make up the robot are nowfound out, they've rotated.If I was to increase the recursionto say,recur=6,hopefully, I'll get 6 found out rotatedand I reload it again.That one, you can seeas we increase the recursion,they fan out.That's giving me the geometry that I want,as well as the abstract graph structure I want.I've now got the-- that's now being appliedto the geometry as well.Imagine if I now have another linkthat hangs off of B,I could then fan that one out as well.That's all good. I'm now finding outand it's parameterized in the genome still,although it looks like I've hardcoded it.It's based on that parameter, on that parameterthat comes in from the genome.If the parameter is smaller,then you'll get a small fan,if it's higher, we'll get a big fan.That will allow it to come up with all weird combinations,and so on.That is the endof this bit of coding.In summary, we've just been looking at the problemof overlapping robot parts which is caused by recursionand not changing the angleas we create them.We looked at a solutionwhich is to have a sibling number,sibling X of Y childrenso we can now work outhow much to rotate it by,based on which sibling we are.In this video, we've just been solving a little problemwith the geometry of the robot."
}