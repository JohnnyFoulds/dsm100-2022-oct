{
  "course": "DSM100-2022-OCT",
  "topic": "Topics 5&6: Creatures",
  "title": "Lecture: Roulette wheel selection",
  "url": "https://learn.london.ac.uk/mod/page/view.php?id=96326&forceview=1",
  "transcript": "-In this video, we're going to start out implementing the selection processby building the roulette wheel.Basically, we're going to do two things.We're going to generate a fitness map from a set of evaluated individuals,and then we're going to use that fitness map to select parents.Okay, how does the fitness map work?Imagine we have three creatures.You can see on my slide here I've got creatures 1, 2, and 3,and each of them has a fitness.2.5, 1.2, 3.4.That's how far they moved in the simulation.Then my fitness map that I want from thislooks like that list of numbers at the bottom.What I do is I essentially iterate through the creatures' fitnessand I create a summed value as I go through.You can see 2.5. I add 1.2, that gives me 3.7.Now I add 3.4, that gives me 7.1. That's what I want.If my input is the list of creatures and their fitnesses,the output is that which is what I'm calling my fitness map,which I'm going to use for my roulette wheel selectionand I'll tell you how it works when we get to the next slide.Let's start out by implementing it.Def test, I'm in my test population function here, Fitmap.What we're going to do is we're going to basically set up--assume that the fitnesses are the ones that I have in that slide.2.5, 1.2, and 3.4.Those are the fitnesses.I want to create a function, which takes the fitnessesas an input and returns the right fitness map.Fitmap, and what I want,okay, so I write I want this, I want 3.7 and I want 7.1.What I can then do is create the fitness mapby calling a function on populationand check if it's correct, right?It's population.Population.get_fitness_mapfrom these fits.It's going to be a static function,which means that it's stateless so it's easier to test generally.That's it. Let's go over to populationand let's run it just to prove it doesn't work.Okay, it doesn't work.Population has no attribute,doesn't have that attribute get_fitness, because I haven't written it yet.Fine. Okay, population.Let's jump over there.I've got my population class up here and I'm going to close up my terminal.I'm going to have to define a static methodcalled get_fitness_map,and it receives a set of fits.Fitmap equals somethingand then I'm going to say--I'm going to do it like this, total equals zero,and I'm going to do for f in fits,total equals total plus f.Fitmap.append total.I'm just going to return fitmap.Really, I just iterate over accumulating basically.You can see I'm just adding it to the totaland appending it onto this fitmap arraywhich eventually I return.Let's run that test againand I'll get out the way.You can see the test is passing now.Let's give it something maybe a little bit--We could do more testing, we could write a bunch more tests here.Actually, I'm not even asserting anything.I'm going to do assertEqual that fitmapis equal to what I wanted.It's actually a test now.Okay, good it's actually passing the test now.That's good.I'm getting back what I wantedand I could obviously give it more tests, but I'm not going to do that.Once I've got my fitness map,the question is, how do I then select a parent from that?Here's where I'm going to draw you something.Imagine I have my fitness map,it's going to look like this.I'm going to have one, two, three.I'm going to say that's 1.2.Actually, look, let's not have these.Let's just get rid of the circlesbecause I don't think they're very helpful.Oops.I've got my fitnesses there, I've got 1.2,sorry, my fitness map rather.I've got 2.5, 3.7, and 7.1.2.5, 3.7, 7.1.What I'm going to do is I'm going to use NumPy to generate a random number,which say is 1.5 or in the range zero to 7.1.Then what I do is I say, well,I look at each of these things in turn.That's index zero,that's index one,and that's index two there.What I'm going to do is I say,I get this value, 1.6, and I say,\"Is it less than or equal to that?\"If it is, then return the index.In this case with 1.6, I'd get an index of zero.If I generated instead the value, say,I don't know, 6.7.Obviously, that is going to skip that oneand is going to skip that one, it's going to skip that one,it's going to get to this one and say, \"Is it less than or equal to that?\"It is.That means that it's going to return two.Let's implement that.I go back to the code,and it's going to be called select parents.I do def testSelPar.Again, I can do this, copy all of this.I don't need one.I've got my fit mapand now I want to say P1 idor pid equalspopulation.Population.select_parentfrom fitmap.Then what I can assert is that maybe it's less,the parent should be 0, 1 or 2.I can just do self.assertthat parent ID is less than 3and that will be a good test, or a basic test.Again, I'm failing that testbecause population has no attribute select parent.Let's go ahead and implement that in the population class.It can be a static function, static method.I do def select_parent, and it receives a fitmap.Here's how we go.We're going to say for--First of all, I have to generate a random number.I'm going to do import numpy as np.Okay, I've got my NumPy library nowand then I'm going to generate a random number.I say r=np.random.randand that'll be in the range 0 to 1,and I do r equals r times fitmap,last item in fitmap scale.That's it. It's basically scaling it by the last item.In the case of this one,it would be a number in the range 0 to 7.1because 7.1 is the last number and we assume it's a sorted list.Okay. Next step is I need to iterate over the fitness mapand select my index.For i in range length of fitmap.I say if fitmap,no, actually, if r is less than or equal to fit map i,then return i.Okay, and that's it.Let's do a test.All right. Sorry I'll just get out of the wayso you can see that one.I create a random number,I scale it into the right range,then I iterate over the elements in the fitness mapand I check if the random number is lower than that element,and I return the index of that element.That's exactly what I showed you previously on the thing.Let's run that test.You can see it is now passing that test.I might deliberately set up some slightly trickier testsjust to make sure it's doing what I expect.Imagine I had say, a fitness of 0,a fitness of 1000, a fitness of 0.1.It should almost guarantee that the value is one that comes back,because it should always be between 0 and 1000.It's very unlikely to be in that range.It should always give me that one.Let's just run that and we call that Par2.Let's just run another test.One is not less than one, oops, I've got the wrong assertion,should be assert equal.Okay. If I could spell assert, that'd be okay.There we go. That's done.That's passing that test now.I can run it a few times.If I ran it 10.000 times, probably, I'd find that it was going wrong,because at some pointit's going to get a value in that range, which is very unlikely.That's a good test.Okay, that seems to be working.That is more or less it.What we've been doing is just been quickly implementing the core functionalitythat's going to allow us to select parents using a roulette wheel technique.You see it's a pretty simple algorithm really.We just accumulate the fitnesses into a list,and then we generate a random numberand choose one of the indexes in that list.That tells us who the parent is going to beand I just demonstrated at the end there that if you've got a very fit parent,who's got 1000, then you can see that it's selecting that one every time,whereas in the other one it's more random.In this video, we have just been implementing the basic roulette wheel."
}