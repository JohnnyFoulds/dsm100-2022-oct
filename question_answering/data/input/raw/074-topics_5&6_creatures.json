{
  "course": "DSM100-2022-OCT",
  "topic": "Topics 5&6: Creatures",
  "title": "Lecture: Running creatures in simulation",
  "url": "https://learn.london.ac.uk/mod/page/view.php?id=96315&forceview=1",
  "transcript": "[music]-In this video, we're going to do the hard workof building the core code for the simulation.In summary, we're going to start by creatinga new module with a simulation class in it.Then we're going to create a run_creature function,which allows us to run a creature in simulation.Then we're going to look at the update_motors functionor create the update_motors function,which moves the creature while it's in simulation.Finally, we're going to look at a way of seeing wherethis creature is at the beginning of the simulation and at the end,which will lead into the fitness function that we'll implement later.First off, building the simulation class.Let's go to the code editor, what I want to do is, first of all, create a file,which is called Test Simulation.Now, I'll just say that I'm not going to writereally detailed unit tests for every singlething that I'm doing because I just want to get through it in a reasonable time.I'm going to use the unit tests as a way of runningtests against the code in a more basic way.We'll see what that means as we go on.Let's import the unittest, and let's create a class called TestSim.What we'll do is we'll start by defininga test basic, does it exist, test.We'll do sim = simulation.simulation,and self.assertIsNotNone(sim)and I need to import simulation as well.Finally, I need to do unittest.main.Okay, so, let's run that.Import simulation is throwing an error becauseI don't have a module called simulation, which makes sense.Let's go back and create that.I go, Create and then Save Assimulation.py.In this, what I wanted to do is basically write a simple simulation class.I'll do class simulation, and I'm going to define a simple constructor.Just pass for now.That should be enough to pass my simulation test.Okay, ran the test, passed it.Okay, great. What's next?What we want to do next is start thinking about setting up a pybullet environment.When we instantiate a simulation object,we want it to go off and create a pybullet environment, ready to run the physics in.How do we do that?Just before we get into it, every function in pybullet, moreor less, has an additional parameter, which we've not seen before.I'll just show you an example of that.If we go into, say, resetSimulation,which is one of the functions we're going to be using,so resetSimulation has this physicsClientId parameter.That means that when you call these functions,you're telling pybullet of the several physics engines that are available,which one you're going to be calling that function on.That means you can have multiple physicsengines running inside the pybullet environment.That's what we want to do because we want tobe able to make this multi-threaded eventually.How do we do that?What I want to do is write a test to say, do we have that value?TestSimId,and so let's create a sim.We're going to do the same thing again,but we're going to check that it has a physicsClientId.self.assertIsNotNone(sim.physicsClientId) so that's what we need to do.That test is failing, you can see because it doesn't have a physicsClientIdyet because I haven't created a physics engine.Let's go back to simulation and do that.Import pybullet as p.What I'm going to do instead is I'm going to doself. = p.connect(p.DIRECT).Now, you'll notice that previously, what we put there is p.GUI.p.GUI creates a physics engine with a graphicuser interface that we can then run in real-time.We can see things moving around, but we don't need that.What we need is a physics simulationthat's going to run as fast as possible offline,and potentially run it in the multiprocessor setupso that we can run several of them at the same time.That's what the direct mode allows us to do.It allows us to have an offline physics engine.That's it.That will create a fresh physics engine for this simulationand remember its ID so that we can use it later.No module names pybullet.I just need to make sure that I'm in the correctPython virtual environment.Sometimes when you start your code editor,you might not be in the right virtual environment.I'm going to make sure I am by telling it where Python is.Python is there, so what I can do is I can just whack that in,and so that's the path for Python.Let's try again. Okay, great.That test is now passing because I told it to runin the correct virtual environment with pybullet.The next thing I need to do is, I've gotmy unique physicsClientId, I need to get onand write the run_creature function.The run_creature function is the guts of it really.This is the thing that actually takes a creature and runs it in simulation.Let's go ahead and start coding that up.I'm going to, again, write a test for it.I'll do def testRun.It's going to say, I'm going to import creature into this because I'm goingto have to create a creature to run in a simulation.We can do Sim, and Sim is there,and cr = creature.Creature and I need to do (gene_count = 3).I've created a creature, and then I can doself.assertIsNotNone(sim.run_creature).Actually, I don't need the creature yet, so I can just come in the [?] now.Okay, now let's run that. It's going to tell me,\"Okay, you failed a test because simulationhas no attribute called run_creature.\"That's the problem, so, I need to go and implement that.Here we go, so, we define a new function called run_creature.It's going to take as its arguments, the self because it's stateful,it needs access to the simulation.There, we need self, and then we have a creature,which we're going to call cr.We're also going to say how many iterations we want to run it for,but I'll default back to 2,400.The reason for that is that, in the pybullet environment, what it does,when you run it in real-time,is it actually updates the physics engine 240 times a second.It might not update the display at that speed,but it iterates on the physics engine 240 times a second.By choosing 2,400 there,that gives me 10 seconds of simulation if I run it for that many iterations.Run_creature now exists, and I'm just going to pass,so that function should run now.I'm running all the tests, I'm passing.Great. That's good.The next step is to continue working on my run_creature function.What's it going to do?It's going to reset the simulation, it's going to set gravity,it's going to write a creature file to XML.Let's get to that point because that's all fairly straightforward.I'm going to go over here,and what I want to do is say, p.resetSimulation.The simulation I want to reset is going to be the one with this ClientId.I'm going to pass it that.I'm going to have to do this for pretty much every timeI call one of the pybullet functions,I'm going to have to pass it the ID of the physics engine which I want to use.Reset it, and then do setGravity.I'm going to setGravity to-- In fact, what I'm going to do,just because it's a little bit verbose,having this self.physicsClientId all the time, I'm going to do pid equals that,and then I can just drop pid in here.Just because that's a bit neater.Okay, now, setGravity, and I'll setGravity to 0, 0, -10,and then again I need the physicsClientId argument = pid.That'll reset the gravity and the simulation.The next step is to figure out how to get the robotor the creature loaded into the simulation.In order to do that, I need to render it out to XML.Now, at this point, we can get intosome engineering discussion about which bit of the programshould be responsible for writing the XML out to disk.Should it be the creature or what?I'm going to decide that it's going to be the creature that generates the XML,the string, but the thing that's using the creature is goingto be responsible for what you do with that string.In this case, it's the simulation that's responsible.What we do, I'll just need to adapt the creature.It's got a couple of slightly annoying features,which is that you have to call certain functions before it will work properly.What I'm going to do is I'm just going to call self.get_flat_links.I'm going to do self.get_expanded_links.The creature, that means the creature is going to be ready to use before I run it.Now, next thing is I'm going to go into my simulation and-- Actually, no.Before I do that, I'm going to go into my test,and I'm going to write a test, which is, after runSimulation has been called,I want to make sure that the creature has actually been written to disk.Let's just get this whole test here and testRunXML.Then we're going to create a creature, and we're going to verify.After we run what we're going to call sim.run_creature, passing it the creature.Then I want to verify that a file has been written to disk.Now I'm going to decide that the filename is going to be tempt.urdf.I'm going to do self assert.Self.asserTrue(OS.path.exists.It's going to be temp.urdf.That will verify that, by running creature,a temp.urdf file was generated, and it will say I need to import OS.That will verify if that file has been written to disk.If I press play again, you see that's now failing that test becausefalse is not true because the file doesn't exist,so I need to go back to simulation,and I'm now going to write the file to disk.I'm going to do XML file='tempt.urdf'.That's the file name.xml_sr=cr.to_xml.Fine, and then I'm going to do withopen(xml_file, -f.write(xml).Sorry, that should be str.F.write(xml_str).Okay, so that should be enough to write the XML file to disk.If we go back over here and run the test again, hopefully now, it is passing.Yes, it's passing that test now, so, the XML file has been written to disk.I can even go and have a quick look at it toverify that it is what I think it is.In theory, because it's a random creature,if I run the test again, it should change.I don't know if it's changed or not, but it probably has.We could even write a test that checks that it changes.What's next?We've written the file to disk,so the next step is to read it back in again.I now need to do cid =, and I'm going to read it in, so, I doloadURDF(xmle_file).Now I need to specify the physics engine ID becauseI'm loading this XML file into this physics engine.Then that should be good to go, so, I'm happy with that.Then next step is called stepSimulation to step the simulation through.Before we do that, let's just run our tests againjust to verify that that load is not failing.Yes, that looks good.The load is working so that's good.What I need to do now is stepSimulation.Remember we were saying earlier, that the stepSimulation,you would typically want to run 240 steps per second.That's how quickly it updates, so, let's just do that.We've got these iterations up here, which is going to give us 10 seconds.I can simply do for i in range, or, let's give it a more meaningful name,for step in range (iterations).I just p.stepSimulation,and I pass it the physics engine ID, and that's it.That was easy. Let's just run the test again, see if it's fallen over.I don't know if you saw that, but it thought about it a bit more.Let's run that again, just to see that again.Possibly thought about it a tiny bit more because it was now running a simulation.If I was to pass it a much longer number of iterations,let's say we do 10.000 iterations, let's see if it slows it down.Not much. It's pretty fast, which is pretty cool.Anyway, so that's good, so, let's get rid of that.Just run the creature.Right, so, the next step is the update_motors function.I'm going to jump over to my slide here.Every one-tenth of a second, we're going to update the motors.Why every one-tenth of a second, in the example script that we saw earlier,which loaded in the random creatures and random,I was basically running the thing in real-time,but then sleeping for 0.1 seconds.It meant that basically, every tenth of a second, it was updating the motors.Now, remember when we update the motors,we're not moving them to a specific position, we're updating their velocity.They might be moving, but with our update,which is one-tenth of a second, we're saying, \"Move a different way.\"We're changing the direction or the speed of the movement.It's okay that we don't update them all the time becausethe simulation will update them because they're moving anyway.I'm going to cheat a little bit here because this code is a bit gnarly,but I will explain exactly what it's doing.This is my update_motors function.I go back into the simulation,and I'm going to say def update_motors.Now, what does it need?It needs self, it needs the ID of the creature,and it needs the creature itself.What it's going to do is,and I'm going to just put a comment in here for the first time,which is that cid is the ID in the physics engineand cr is a creature object.Okay, now we can whack this block of code in, and then fix it up.This first line here, let's go through it,is iterating over all the joints in the creature.It's worth noting that--Okay, let's just lay it out a bit neater.It's asking the physics engine how many joints this particular object has.Creature ID is actually cid.Then it's telling it what the physics ID is.It's, in this physics engine,this creature, how many joints does it have?Then, I get the motor from the creature.Remember the creature has this list of motor objects inside it,which we defined earlier.Then I'm going to update the speed of the motoraccording to the state of the motor basically,so, control motor, velocity control.That means it's changing the speed of the motor,not the actual position of the joint.Then the velocity is going to be the output of the motor,and finally, we set the physics engine ID to that.The question is how do I make it run every 24 steps basically,which is one-tenth of a second?I can do if step Module O 24 == 0,then self.update_motors,and I pass it the creature and the creature ID.Oh no, the other way around.It's creature ID and the creature.I can even make that really clear by just doing it like this.Okay, that should be more or less it.Let's just, again, run the simulation,which is going to test whether it's actually working or not.Hit Play.Okay, that all worked, nothing crashed, so, that's good.The final step is over here.The final step is updating the position of the creature.The way I'm going to do this is I'm going tohave an update_position function on creature,which, when you call it for the first time, it will set its initial position.Then, on subsequent calls, it will update the final position.You'll see how that works when I get into it.Back into the creature code here.Over to creature, and I need a function called update_position.It's going to receive self and a position.What it's going to do is I need to put some--When I create the creature back up to the constructionof the creature over there, I'm going to doself.start position = None, self.last_position,let's call it, last_position = None.Then what I'm going to do is the first time these get called,so, if self.start position == None,self.start position = position,else: self.last position = position.That bit of logic there is basically, first time update_position gets called,it stores it as its initial position.Then subsequent calls, it just updates the other one, which is the last position.That'll allow me to have two positions so I can compute how far they moved.I just need to call update_position on the creature now.How do I know what the position is?Luckily, there's a nice function in here calledgetBasePositionAndOrientationin the pybullet API.I'm going to do that every step.I can say cr.update_position but I need to get the position.Whoops.The position and the orientation =p.getBasePositionAndOrientation.I need to say which thing, which object, so, its creature ID,and also which physics engine of course.I want to say, \"Give me the position of this creature in this physics engine.\"Then I just need to pass that position to the creature.How am I going to test this?I'm going to verify that the creature'sposition has changed during the simulation.I just do exactly this, and I'm going to verify that this creature'sposition has changed because the chances are,you saw how it instantiates, it pops, flies up into the air, then lands.There's a good chance that in 10 secondsthat creature is going to change its position.I'll just write a test that does that.I'm going to do testPos, and then my assertion isself.assertNotEqual(cr.start_position, cr. last_ position).There's my assertion, and I'll save all that.Make sure I've saved that one and that one.Let's run it and see what he does.Okay, that passed.Just out of interest,let's print out the position of the creature to see what it is.Here, we can do print(cr.start_position, cr. last_ position)just to see what they are out of interest.You can see there's the start position, it's -2.55, -5, -0.It's there.That's actually slightly below ground, interestingly.Then you can see it ended up going in that direction,and it's really ended up miles below the ground, which is weird.Unless minus means up, I don't know.You can see it's clearly moved, and that's the important thing,it is the creature has changed its position.That means we've got a pretty good sense that somethinghas happened in the physics engine where the creature has moved.I'm happy with that, and I'm going to end it there.What we've been working on is this new module, which allows us to do simulation.We wrote a run_creature function, which initializes the simulationand puts a creature into it, and then moves it aroundand updates its motors with the update_motors function.Then at the end,we implemented some code to start the creature at a specific position,and then work out where it moved to by the end.In this video, we've started out implementingthe main code for our simulation."
}