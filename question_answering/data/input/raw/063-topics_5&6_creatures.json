{
  "course": "DSM100-2022-OCT",
  "topic": "Topics 5&6: Creatures",
  "title": "Lecture: Converting from flat genes to a graph: algorithm",
  "url": "https://learn.london.ac.uk/mod/page/view.php?id=96282&forceview=1",
  "transcript": "[music]In this video, I'm going to explainhow we're going to go about taking a flat genome architectureand converting that into this expanded graph structure.In summary, I'm going to start by reminding you what the gene structure is,if that isn't clear, and then we're going to look at the graph structureto see what the target is.Also talk about the fully expanded graph structure,which is the ultimate target here.Finally, how we then get that expanded graph structureand convert it back into a URDF,and what we'll see is the pseudocode algorithm that we're going to buildactually does that for free as a result of how I've designed it.Let's get into that.This is the structure of a gene.You'll remember from the previous videos that what we're doingis essentially generating lists of random numbers,and there'd be a certain number of these and say 14, I think it was.Each of those numbers represents a parameter on a link effectively,which defines how that link connects to other links what size it is, how the joint works, all that stuff. We define all of that as a list of numbers.We have several sets of these lists of numbers,each of which we might refer to as a gene.What we need to do is take that flat array of arrays if you like,or list of listsand convert that into something that looks like thisand ultimately something which looks like that.Now, let me just get into that and explain what I mean.The first thing to talk about is the basics of genome structure.We have these lists of numbers that look like that.Each of those is a random number, and each of those is a gene,and what we're saying is each of those genes converts into a link,which is a body part, if you like, for the robot.There was a complexity here,which is that when we link from say body part B to body part A,we have a recurrent relationship,which says we can actually make repeats of that.If you saw in the structure, we were looking at on the slide there,we actually had-- when we defined our C we had two links going from C to B.Then we had another thing which was D, and that had one link going back to C.What that means-- whilst each of those would be your gene.We'd have another gene that defines that one and another genethat defines that one.It's four genes and there's four different types, four different nodes there if you like.What it means if you've got that structure where you have the two links here,is that it basically is recurrent.We'd actually end up with the expanded graph.We'd have an A, and it would have a B, which is easy enough,but then for the C, it would have two.You'd have two Cs like that, and you'd have a D,for each of those two Cs, you'd have to do that.What the trick is, we need to get from this flat structureinto this structure first with the recurrent relationships.Then we need to take that and expand it outinto this full structure here,which is what I'd call the expanded graph structure.That's what we're going to have to do.Then eventually we need to pack that down into a URDF file and do that.Let's go through that.I'm going to do it in two phases.Phase one is going to be this part where we get from the--sorry about the messy diagram,from the genes into the list of core node types or link types.Then the second phase is when we are going to take those core link types,and we're going to expand them into the actual total number of linksthat we're going to need in the eventual robot body.I'm going to mention one more thing here, which is the developmental process.Remember that as we are building out our robot,we have this developmental process.We start with the root node, and then we add another one.That's the first gene.Then the next gene would be B, and the idea is that this one can link to,or can be connected to-- got to be careful with this word link.Each of these is a link, a link is a body part,a joint connects two links together.That means that B is going to have a joint connecting it to A,and because of the developmental process,B only has one option as to what it's going to connect to.That's fine.It has a parameter in its genome,which says, which parent do you connect to from zero to one.In this case, it doesn't matter what that parameter is,it can only connect to A because there's no other things leftbecause we build it one by one.Now, when we get to C, when we add our C in there,depending what the genome parameter is, it could either connect to B like that,or it could connect to A.If the genome parameter it says between zero and one,if it was 0.3, then it would connect to A,if it was 0.7, then it would connect to B.That's one of the things we can evolve is which ones does it connect to.For now what we know is that actually, that that value must be highbecause it actually connects to Baccording to the graph we've been working on.That's fine. That connects there.Then when we get to D has even more options.D could connect to B, C, or A.Depending what its value is for that parameter,that's what decides what it's going to be.It's obviously got a high value for that because it's connecting to C.That's what we mean by developmental process.What I want to do now having laid that all out,I'm going to just write the two phases algorithm.Remember phase one is going from the genes to the flat list of links types,and then phase two is going from the flat list of link types,and then processing this recurrence relationship where we have multiple linkssorry, multiple connections from one link to another.We basically expand that out.How are we going to do it?I'm going to just bring up my text editor here and start coding.Phase one pseudocode.It's basically going to iterate over genes,and it's going to start with a--I'm going to have an array called flat links.The flat links array, its going to be an empty array.Iterate over genes for each gene.Create a link and add it to flat link this array.Let's call it an array because it's an empty array.That's it.You end up with-- that's it, that's easy.The other thing is we need to just decide what the parent is.Decide parent link name.We might actually assign each link a unique name, decide parent link name.That's it and actually, probably we want to for each genome create a link,then let's just rearrange that a bitinto a sequence of steps. That's more like it, isn't it?That's our pseudocode algorithm for phase one.We basically iterating over the gene.That is going to give us-- if we have to draw that out,that would look like-- the output of that would be basicallythis kind of thing with A, B-- sorry.My shape recognizer thought that my square was a circle,A, B, C, and D.That's going to give us that.It's just going to give us that flat link structure.Great.Now, what's next? Phase two.This is where it gets tricky.Let me get out of the way. Phase two.Let's bring that up a bit.Phase two we're going to have another empty expand links equals empty array.Now we're going to define a function called phase twoand phase two is going to take a parent link.It's going to take the flat linksand it's going to take the expanded links as arguments.Just to say, if you've followed any of my software engineering videosbefore then you'll know that I don't like global variablesand so what I'm going to do is I'm going to pass into this functioneverything it needs to do, what it needs to do.It's not going to pull out some magical global variables.That's that.Basically, I've got my phase and it takes those three argumentsnow what's it going to do with them?Well, it's going to say to get say children equals getand imagine there's a function called get children for parent link.We know how to do that.Basically, how do we get the children for a parent link?We go here and we say,\"Okay, that's my parent link give me all the children,\"which in this case would just be B that would just give me B in the first instance.Then what we're going to dois going to iterate over the children for child in children.Okay, what we are going to do with it?We've now got our B.What we are going to do with B?We are going to, first of all, we're going to add child to expanded links.Wait, let's make it like this.Let's go a little bit pythony.Append child.Then we're going to say for recur in child.recur.Actually, we're going to do that here. Sorry.I forgot so I need to do that recurrence thing first.Yes, so I'm going to say, how many recurrences does this child have?For each recurrence, I'm going to add one to the expanded links array.Then I'm going to call phase two.This is the trick.This is where it gets recurrent.Now, just to say-- just getting grokking, as they say,getting your head around some sort of recurrent functioncan be a bit of a mind-expanding experience,which makes it great.Yes, it's not as easy to always get it the first time around.Some people can.For me, it takes a little bit of screwing on it to get it into my headwhat a recurrent function is doing.Let's go for it.What it's going to do, it's going to iterate over the number of recurrencesthat child has.Let's just assign that number here.Remember, this is going to be one, one, two, and one.How do I know those?Because remember going back here, we had two links going from C to B.Then only one link going from D to C.Those are the recurrence values which should be genetically encoded.Remember these are mutatable things that are genetically encoded.We figure out the recurrence value and we created one child.We added copy of the child.Copy of child, because we're going to be in python.We're going to make a copy of the child,we're going to add it to the expanded links.Then we're going to call phase two,sending it child and, obviously, flats and expanded links.What's it going to do?What's going to happen there?It's just going to call phase two again.What is phase two doing?Gets the children for that one,so if we're on-- Let's just go through this.We start off with A, and we get the children of A,which is just B and we count the number of recurrences for each recurrence.This is our expanded links.For each recurrence, we're going to add the two expanded links.Okay, fine.That's B.Then we're going to get the children of B.That would give us C.Children of B is one C, and then for each recurrence,we're going to add it.We add it, that gives us a C.We add it and then we recur in.On the first child, we're recurring in,if you like, we're digging in, and we're getting D,and we're going to add that onto the array,because it's got recurrence one, so that adds D on,and then we're done.We're done with that branch because there's no more children of D,so we're done with that and we go back up to C again.We're going to add another C onto expanded links,so we're going to end up with the C.That's all right, a circle is okay.We ended up with a C there.Then we're going to go from C down to D againbecause we get the children of C, remember?We're going to add- swipe that, that's a C.Then we're going to get the children of C,we're going to add that onto there and so on.Eventually expanded link is going to look like this.It's going to have an A, a B, a C, a D, a C, and then a D.That's what the algorithm is going to do.It's very simple, isn't it?Really not that much going on.That's how we dig in and we expand it into this array.To do the final stage, remember the final stage was--If I go back to my slides--The final stage was this.We need to get out from our expanded graph description into the URDF.You can see behind me there.URDF there.You want to get that back out, then it's actually quite simple becausewe've just got this-- We've already got our--These are all our links,so each of these things in expanded links is going to convert into a link tag,and each of them is also going to have a joint tag,which dictates which parent it connects to.We know that because we do that in phase one,we figure out what the parent is.Each of these in expanded links over there has a parent already,we just need to generate a joint tag that does that.In the next video, we're going to be actually doing this in code.We're going to check what comes out, verify,and see if we can turn that into valid URDF,which we can load into the PyBullet environment.Just see what it looks like from, say,a random genome into a random graph structure for a creature.Okay, let's finish there then.That's it.We've just been through the process of convertingfrom a flat gene structure into a flat graph structureand then into a proper expanded graph structureusing a recurrent functionto keep digging into each branch of the graphand doing the recurrence,to make sure we repeat the branches where necessary.Then, finally, we talked about how we can convert that intoa URDF file or XML data at the end.Okay, so in this video we've just been converting froma genome into our expanded graph structure."
}