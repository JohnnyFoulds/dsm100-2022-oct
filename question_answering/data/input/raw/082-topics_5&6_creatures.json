{
  "course": "DSM100-2022-OCT",
  "topic": "Topics 5&6: Creatures",
  "title": "Lecture: Saving and viewing fittest",
  "url": "https://learn.london.ac.uk/mod/page/view.php?id=96333&forceview=1",
  "transcript": "In this video, we're going to complete the GA by adding some export capabilitiesso that we can actually see what the creatures areas they're evolving.We want to be able to export the genome to CSV.We could probably look at the XML filesbecause we've already got that implemented,but the problem with the XML file is,it doesn't contain information about how the motors run over time,but we can get that information from the genome, so instead,we're going to write the genome to disk because that's the ultimate descriptionof the creature. We're going to export to CSV.We're going to import it back in from CSVand just see how we can generate the DNA from a CSV fileand then we're going to add some code to the genetic algorithm so that it savesthe elite creature's DNA out to disk every iteration,so we get a copy of the best creature each time, which we can then review laterusing the final step, which is to actually be ableto run something that we've loaded in from CSV in a real time simulation.First of all, exporting to CSV.What we're going to do, we're going to basically iterateover the genes and write the values of each gene out as one linein the CSV file.One line will contain all the values for a single gene,so we'll have multiple lines. How do we that?Well, I've got my test genome script open here,and I'm just going to write a quick test to start this off. Test tocsv.What I'm going to do is essentially just write out to seeif it can actually generate a file.I'll say g1 equals and I'm going to put a known genome in there.I'm going to say genome.Genome.to_csvand I need to tell it I'm sending the g1and the need to pass it, the file name, so test.csv.I'm just going toassertTrue.Having a little trouble writing assertTrue there.It's os.path.existsand test.csv.It's basically just testing if it's written a file or not.I think I need to import os, if I haven't already.I've got os imported up there, so I've got accessto that path.exists function.Let's run this test and you can see that it's failing because genomedoes not have a to_csv function yet.Let's go to our genome script and write that.I'll get rid of the console. Over to the genome.I'm going to put it at the bottom of those mutation functionsthat we were working on before.Let's just do it here, static function.It's called to_csv and it takes two arguments,which is the DNA and the CSV file.All I need to do is I'm going to create a CSV string,and then I'm going to do it with open CSV file,in write mode as f, and I do f.write.I'm just going to write the CSV string to disk,which is currently empty, but that is the minimum codeto pass the test.Let's run that code again.Let me pop that up.You can see it's now passing that test.I've commented out all the other tests, by the way.That's why it's only running one.It's running one test.I'm going to write another more challenging test,which is to check what's actually in the CSV file.This time I'm going to do this stuff,but I'm also then going to say,I expect to see in my-- I expect to read back from the CSV file,1, 2, 3, then comma, an extra comma at the endand then an end of line character.That's what I'm hoping to see from the CSV file there.Then I can then read from this what I actually got,which is CSV string equals,with open test.csv as f.CSV string equals f.readand then I can just sayself.assertEqual CSV string and expect.Basically I'm saying, verify that the string that I read infrom disk is the same as the string that I've expected to read inand of course this is going to fail as well because it's just writinga blank string, so you can see it saying assertion failed.Blank string is not equal to 1, 2, 3.I need to do some work now and actually implement this properly.What am I going to do?I'm going to say, for gene in DNA,CSV string and then for value in gene,I'm going to do CSV string equals CSV string plus string versionof the value plus a comma.Then once I've done one gene, I need to add a line,so I do CSV string equals CSV string plus I'll add the end of line character.That basically will print all the values out, convert it to strings,and then add an end of line character at the end.Let's run that one.Now that test is passing as well, so that's good.I've realized I've got two with the same name.Let's just do that and check that it's actually passing.It's passing the two tests. Okay, great.That is writing out to CSV.I could write one more test to try out a two liner, just to make sureI'm really happy it's working okay.If I do a thing like this where it's got two lines, 4, 5, 6,and in that case, I would expect to say 4, 5, 6, then an end line.That's just a two gene genome and I'm checking that I get two lineson two separate lines there. Oops.I've got some indentation problem.Oh yes, run again.That test is passing as well.Even with a two line genome or two gene genome, that's working too.The next one that we're going to implement is the import from CSV.This is a little bit more complicated because we've got to--instead of just pumping this stuff out to disk,we've got to parse the strings and split them up and stuff like that.This is the rough process we're going to follow.We're going to read a file into a string, so I'll read the whole file in,first of all, then were going to split it on the end of linesto get the separate lines in the file and then we're goingto basically split each line in the file on the commas, and then converteach of the values that we get into floating point values.Then we can compare arrays that we get from this with np.array_equal,if we want to.Over to this, and this time I'm going to do def test_from_csv.Let's write something out to disk.We're going to write a CSV file out to disk first of all.Then we're going to read it back in.We're going to say g2 equals genome.Genome.from_csvand I just write the name of the file in this instance.Then I do self assertTrue,and I'm going to do np.array_equaland I pass it the two arrays. It's going to be g1, g2.That's the way I can do it. Let's run that test.You can see that test is failing, we don't have an attribute from CSV.That means we need to write that function.Let's go over to this and do that.Again, this is going to be static.Def from_csv file name.Let's go through that algorithm that we just saw on the slide.Read to a string and split it on the thing.First of all, I start off with an empty string,actually CSV string equals empty, with open, file name as f.We don't need the write mode because we're just readingin default read mode now.I can do CSV string equals f. read.That'll read into the string and then I do lines equals csv string split,which is a built-in function on the string there.Split on the end of line character for line in linesand then I do vals equals line.split on the comma character.Then I can use a list comprehension to squash that set of values downto a nice array of floats. How am I going to do that?Well, let's start off with a DNA array here.I can say gene equals float versionof v for v in vals.if v is not equal to an empty string, because we might end upwith empty strings in there, it might be an empty line,we can do it like that.Let's just check if we got something.If length of gene is greater than naught,then dna.append gene.Finally, return dna at the end.That's the basic algorithm. Let's just go through that.We create an empty string, we open the fileand we read the whole file into the string.We create an empty array, ready to store our genes as we read them in.We split the contents of the file on the end of line characterto give us all the lines.Then we iterate over the lines and split into an array of valuesby splitting on the comma in each line.Then we convert the list of values, which we got from splitting on the comma,into a list of floats and checkonly if the values are not empty stringsand we verify that we got some values and append it to the DNA if so.Let's try it out.Self.assert equals list object has no attribute g2.There should be a comma there. Let's try again.That test passed and just to sanity check it,I can actually maybe print out g1 and g2, just to have a look at them.Print g1 and g2 just to have a look at them.G1 is that, and you can see one difference it's made is that it's converted itinto floats, but luckily the np.array equal is happyto accept that 1.0 is equal to 1, so that's cool.We could do one more test the same waywe did before with two gene genome.Let's do that and go 4, 5, 6, like that.That's a two-line genome just to put a 2 there and run that.That also works with a two-line genome, so that's good.That's all working. I'm done on my importing from CSV.The next thing that I need to do is to save the elite creature out to CSVas the evolution is running.I'm going to go back into my genetic algorithm codeand see if I can do that. Here we go.Where is it? Test_ga.I think I actually wrote the whole ga in test_ga in the end,didn't I? There we have it.Where's the bit where I have the elite? I've got it.That's where I'm storing the elite genome onto the replacing the first new onewith the elite one.At this point, I've got access to elite, so I could actually say,if I've got access to gene. I could saygenlib.Genome.to_csv.I could say elite, which I think is a creature,so I do elite.dna.Now the question is, what's the file name going to be?Well, I could call it something like-- I could basically generatethe file name from the iteration.Then I would have a series of CSV files, one for each iteration,and that would be quite neat and I've got a value here,which is generation, which I could use to build that file name.Let's do that.We can just say csv_filename equals string versionof generationplus .csv.How about that? Generation something elite,and then I can just put that there, csv_filename.That's pretty much it.I should just be able to run this and I should see that it generatesthese file names as I go.Let me run that here and see how we go.We should be able to see filesappearing with this. There we go.There's each iteration, you can see a file was created with the genomeof the elite individual, which seems to be the same each generation,which is interesting.Oh, no, slight variations, you can see that value there got mutated a little bitin that iteration from 7 down to 6. It's obviously changing.That looks sensible. That looks like that's working.I'm going to go to my next slide.The final step is to actually be able to run one of these things in simulation.This is the big moment really, because what we're going to do hereis actually load one of these saved genomesinto a simulation, and then run it to see how it looks after the evolution.The idea is that we can then run the evolution many iterationsand see what really fit individuals actually look likewalking around in the world.How are we going to do this? Well, it should be fairly straightforward.What I'm going to do is I'm going to take my test motor script.I've got all this stuff in here, but that's all right.I'll go to my motor_test, it's called, isn't it?Yes, there we go.I'm going to save this one as a new fileand I'm going to call this onerun_genome,basically. Oops, run_genome.I'll call this one run_genome and what this is going to dois it's going to load instead of generating a random creature,which is what I'm doing up there, I'm going to loadthe creature off from disk so I can do it like that.DNA equals genome. Have I imported genome?Yes, let's import genomeas genlib.We call it genlib, then equalsgenlib.Genome.from_csv,and I'm going to maybe pass it3_elite.csv,and then I can do c.set_dna dna.That should be it [chuckles] with a bit of luck.If I run this one, I should be able to see what that 3_elite actually looks like.I've got as far as 3. Yes, let's check.Let's run this one.There it is.This is the one that was able to move the most.You can see it's clearly moving a bit there.It's got some sort of shoving motion going on,which is pretty good.The obvious question is what happens if I run it for a few more iterationsor do a much bigger initial population and things like that?We're going to do that in the next video and we're going to seewhat some really fit individuals actually look like.Let's summarize.In this video, we've just been implementing some codethat allows us to store and reload later the fit individualsas we're running the evolution, which allows us to actually lookat these things and run them in a real-time simulation.We've now got our fully functioning genetic algorithmwhen we're ready to actually run some evolution runs and seewhat kind of creatures we are going to be able to evolve."
}