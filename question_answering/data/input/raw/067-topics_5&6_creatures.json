{
  "course": "DSM100-2022-OCT",
  "topic": "Topics 5&6: Creatures",
  "title": "Lecture: toXML",
  "url": "https://learn.london.ac.uk/mod/page/view.php?id=96294&forceview=1",
  "transcript": "[MUSIC]In this video, we're going to push ahead with the implementationof our creature parsing codeand hopefully get pretty much to the end and have, at the end of this,a complete export to XML, which we can then load into PyBulletto see what the creatures actually look like.Let's get straight into it.My plan is, I'm going to start out by just thinking about how we can actuallygenerate XML tree structures in our code.We've got some code up on the screen hereand I've actually got that in my Text Editor as well.What we're going to do,and I'll just show you this inside an IPython environment,because that's probably the easiest way to do it.Let me just clear that.We go into IPythonand we're just going to play around with the XML code for now.We want to do is import this function from the XML library.If you don't have a miniDOM, you can PIP install it.I've got miniDOM installed,and that gives me a function,from which I can then do everything I want to do with XML, which is cool.Let's go in.The first thing is to create a DOMImplementation.It's a generic way of working with XML.That's going to give me an implementation of an XML DOM.Just to be clear, if you haven't worked with DOMs before,then a DOM is a document object model.It's basically a hierarchical data structurethat we can use to represent XML.If you think about the XML documents we've been looking at,they have tags inside tags inside tags.That's what we mean by hierarchical.Basically, a DOM is a kind of data structure thatrepresents that eventual text file that we see.Next up, we're going to actually create ourselves a new DOM like this.What we're going to do is actually call it starter.Now we call it starter. Here we go.Let's call it starter.That's going to give usa basically an actual data structure that we can work with.We've got the implementation, which is the domimpl,and from that we can then generate a data structure.We've now got a real data structure that we can work with.Let's say we wanted to create a tag.If we wanted to create, say, a geometry tag,so I could do g_tag = adom.createElement,and then I'll just give it a name, which would be, say, geometrybecause that was one of the tags that we have in the robot.What can I do with g_tag?Well, I can do g_tag.toprettyxml,and that gives me an XML representation of it.It's a workable data structure and a manipulable data structure.I can then turn it into a string of XML at any point, which is great.What about if I want to add an attribute to that tag?Well, I can do g_tag.setAttribute.I don't know.Let's say we want to set the length to 10 or somethingand always have to pass it strings as the attribute values,even though it's a float in there.That's okay.I can try that again.You see now it's added the attribute into the geometry tag.Let's say I wanted to add a child tag.Let's say I had a weight tag.Just making this up now,equals adom.createElement(\"weight\").I can do g_tag.appendChild(w_tag).Like that.If I do it one more time, I can do g_tag.toprettyxml.If I print that out, then it should do it properly.Now you can see that I can actually spirit out in a human readable way.If you don't use the pretty one, I think it's just toXML,you can see it comes out compact, a compact version.That's great as well if you want minimum file size for your XML.That's the quick intro to the XML code.What we're going to do now is attempt to adapt our URDF link class,which represents one of the links in the robot.We're going to try and adapt that and get it to generate XML.Let's go back to the code over here.I'm going to do it all from test genomebecause the URDF link class,which we'll just have a quick look at before we carry on,URDF link is in the genome file here.There it is.What we're going to do is we're going to add toXML functions on thisand I'm going to build out some of the codeto convert that into a link tag.I'll show you how that works.First of all, let's write a test,testLinkToXML.The first one is going to be a really simple testand I'm just going to create a link.I've got some code up here that creates a link.link equals-- end.You'll notice that earlier,luckily when when I was adding all the parameters to the link class,I gave them default value.I won't have to pass in all those gazillions of parametersbecause you see, they have a default value,all of those ones.That's fine. I can just use that for now,and that makes things a bit easier.I only need to pass in the name, the parent name, and the recursion level.That's okay.I've done that.It's got a name, parent name, recursion level,and then I just want to see, does it generate XML?xml_str = link.to_link_xml.Now, why to link XML?Why not to XML?Let's just remind ourselves.Here's my robot XML file.You see, it starts off with a robot tag,and then in that I have for every robot part,there's a link tagand then for every link, there's a joint except for the first link.The first link, remember, it doesn't link to anything,it's just the root link and everything else joins onto that.Basically, the number of joint tags that I need isthe number of link tags minus one.Anyway, we're going to do the first bit where we generate the link tags for now.Let's go into that. Back to genome, and there it is.What I want to do is look at my test linkand I just need to self.assertNotNone(xml_str),like that.I can just run that test and it should failbecause you have no attribute to link XML.I need to add a function to that code to link XML.Let's do that.def to_link_xmland it's stateful because it's dependent on its own self. whatever parameters.The URDF link has to have state.That's why we don't use a static method there.I'm just going to earn a string for now because that should pass that test.According to the rules of test-driven development, that's enough.Okay, great.Now, I need to write a better test.The problem is at this point,I don't want to have to write a test for every little tiny piece of the XML.I'm just going to eyeball itand I'm going to load it into PyBullet and make sure it works.What I want to now is just ignore the testing for a secondand just write a bunch of codethat's going to generate the XML tag structure.I'll just show you how that works.What I'm going to do is I'm going to jump out of the videoand then come back in again.At that point, I'll have written all of the code,which is a bit repetitive, that does all the tags,and then we'll be able to see the XML that comes out at the end.Let's just do a little bit of that code now.If I want to generate links,remember, I need to have this at the top of my file that I want use in.Because it's in the genome, I need to put that at the top.Let's put that all near the top in the imports.I need these two lines to create a DOM.Now the thing is,I don't necessarily want to have to create a DOM for every time I call this.I might actually create the DOM,because the creature's going to be the master of all of this.The creature is going to basically generate all the linksand call out to them, pull their XML and put it together.Maybe the creature just needs to create one DOM and then it can do it.What I can do is, say, well, actually, you need to pass me a DOM here.That means I don't need that line therebecause it's going to get passed in a readymade DOM.That means the test code needs to have that linebecause it's going to be doing it.Eventually, the creature will need that.For now, let's just put in the test code.The test code also needs to generate the DOM like this.Let's put that in over there.I just need to do that,and I'm going to pass itwhen I do that, right.I need to pass it the argument of a DOM.Now, the genome URDF link class has access to a DOM.What it has to do is it's just going to create those tags.We're going to refer back to the 101 document which is over here.There's our 101.Basically, we need a robot.To create one of these links, the top level thing is called a link tag.We need a link tag with an attribute nameand then we need visual, geometry, and cylinder.Let's just do a few of those just to see how it works.link_tag =adom.createElement(\"link\").I can do link_tag.setAttribute,and it has a name.It's going to be self.name.There we go.That's where I'm glad I've actually got all of these variables inside selfbecause if it was all tucked away in a dictionary,then my code editor might not be able to find all those things so easily.I'm glad I've done that at this point,so link_tag.setAttribute(\"name\").Then, what's next?Visual tag, so vis_tag = adom.createElement.Let's call it visual.Then next up, we need a geometry tag,geom_tag =adom.createElement(\"geometry\").Then, I need to add a cylinder tag, so let's do that one while we're here.cyl_tag = adom.createElement(\"cylinder\").I'm actually going to add a couple of attributes on that.Cylinder has a length and a radius attribute,so I can do that.I can do cyl_tag.setAttribute(\"length\"),and that is self.length.Oops, self.link_length, is it?Let's have a look.Oh yes, self.link_length.Remember, it has to be a string, so I just turn it into a string like that.Then it's going to have a radius,which is self.link_radius, I think.That's enough for that.Well, let's just return it, then we can build the tree.I'm going to just quickly--I need to add cylinder to geometry, geometry to visual, visual to link.I'll do geom_tag.appendChild(cyl_tag).Then it's vis_tag.appendChild(geom_tag).Then it's link_tag.appendChild,and that is (vis_tag).Then, I can do return link_tag.toprettyxml().Like that.Let's just see what we get backand print just to see that it looks good.Sorry, str.Run the test.Nothing went wrong.Name amom is not defined.I've done something silly.You probably spotted it if you're watching my video.Where did I do it?adom. Oh yes, there we go.I made up a variable name.adom.Back to the test, run again.Let's have a look at it.Link tag with a name.Visual tag, geometry tag, cylinder tag with a length and a radius.Let's check that against the actual 101.urdf.Looks kind of similar.I'm happy with that.I'm going to cut out here and I'm going to jump back inwhere I've completed that for the link tag,and I'm then also going to go ahead and write one for the joints.I'm going to iterate over the links and create joint tags for them as well.I'll give you instructions for this in the worksheet for how I've done it,but it's quite repetitive.It's just lots of link_tag.appendChild, link_tag.setAttribute.All that stuff over and over again.I'm just going to go off and write that.I'll come back, and we'll have the XMLthat we want generating from that function.I've gone ahead and written all of the XML generating code now.We've got two parts, really.We've got toXML on the links, and we've got toXML on the joint.This is a list of all the tags that I had to writeand the various attributes.The link tags were easier reallybecause they've just got geometry tags and collision tags.Then the joint tags had a whole bunch of different tags.Let's just review that code to see what's going on there.I did it all in the URDF link class.Here it is.You see why I didn't want to have to type all that by hand.It's quite tedious.Basically, it's the same stuff.We've got the link tags that we saw before,and then there's the geometry, cylinder tag for the geometry using--these are those parameters coming in from the genome.That's where the variation comes in.Then, we had to create the inertia tag,so that's all in there as well.I messed around with that,but you can experiment with these inertia values to see what it does.Yes, you can see the genome parameters are coming in on the mass.Just earlier, I was saying how it doesn't matter about the mass,we've just said it,but I actually decided to do it based on the volume of the cylinderso it was actually realistic, so it's properly calculated there.That's good.Then in the joint tag, obviously, that gets a bit trickier.In the joint tag, we had the name for the joint.We had to come up with names, and that was based on its nameand the parent that it's joining to.Then we had to set the type.We've got revolute and fixed joint.I allowed both joint types for nowso that some joints won't move, some of them will.Then, we had the parent and child.Again, that's genetically encoded rememberor calculated based on who it's going to link to.Then, we had the idea of the placement of this particular linkrelative to its parent.This is where the axis xyz's and so on come in,and also the other things which are the rpy and xyz.That's to do with the rotations and the different things.I think this axis is dictating how it rotates if it's a revolute joint,and then this stuff dictates where it's placed relative to the parent.Does it rotate and place that way?That's the basics.I think we're ready now to actually generate a full XMLand push it into the PyBullet to see what it looks like.Let's do it.Just finally, before we get to that, sorry,in the creature class,I just quickly wrote a toXML function in that,which basically just pulls up the link and joint tagand iterate for each of the linksand apart from the parent, there's no joint on the parent,and then smashes that all together, adds it onto a robot tag,and finally outputs it as XML.We're ready to go.I've got a test creature function up and running here.If you look in here, this is it.This is all the code that we need.Remember, I was talking about it being a high-level class earlier.This is how it works.You basically create a creature,tell it how many genes you want up there, so gene count.Then, you expand the links,and then you just call to_xml on the creature,and it will do the whole work of iterating of all the linksand generating all the joints and everything,and eventually give you back an XML string,which we then write out to 102 up there.With the open and f.write, we stick XML at the beginningand check that it's not empty.Let's just run that,and hopefully, nothing will go wrong.We should be able to see.The test works, so that should've worked.Now, I'm ready to go over to PyBullet and load that into my code.Where is my PyBullet environment?I do ipython.Let's put that up there.What we're going to do, we got that start to code,so we should run starter there.There's my PyBullet environment.What I want to do is just load in that URDF file that I just created.Let's do p.load.We'll assign it c =.Let me just pull that up in case you're reading the subtitles.c = p.loadURDFand the file name is ('102.urdf').Watch above me and let me get out of the way.There it is.It generated it.No complaints because I've got all the right tags.Therefore, I set the simulation to run in real time.I set that to one.Let's see what it does.There it is.There's our robot thing.We can pull it around.There it is.That is our first randomly generated creature.That's pretty interesting-looking, isn't it?You can see it's got a few different parts there.That's all very exciting.We've got a creature, and we could now go throughand we can start running the engines on it.We can turn the motors and see if it moves.Let's try doing that next just while we're having fun.Let me get out of the way again.I'll zoom in on it a bit.What we can do, setJointMotorControl2.We can do things like setting the position.If we do, say, c and joint 1,I'm going to do, set the positionto mode=p.POSITION_CONTROL.I think I can just pass in a position like this.Let's see what happens.Positional argument follows keyword-- Okay, all right.I think you probably saw that moving there.Let's try that again.If I set it to-- Whoa, okay.Remember, when we do this position control thing,it's rather rapid, isn't it?We can't get a really good view on it.Let's try another one.Okay, 2.5.There it goes.Yes, so we can move the joints around.That's pretty cool, isn't it?We've got a robot that we can interact with,and we can move the joints around.It was all generated from those raw random numbers,and of course, I can generate another one.Of course, let's do that.If I run the test again, I'll get another file.It'll overwrite my original one, but that's okay.Let's get that over there.I'm going to get out of the way.Let's see if we can load up another robot.This time, we're going to do c2 = p.loadURDF,102 again.Okay, well, there's another one.Let's see what that one's going to do.You can see that one's obviously got a different shape.Somehow similar, but different.That's just showing you loading another robot.I want you to run this code now and play around with it.Generate some random robots, and try varying the number of genes,because this is only with a low number of genes.You can also mess around with the parameters.I'm going to come back in the next video,and we're going to see how we can improve this a little bitbecause there are some limitations that I wanted to talk about.There's my summary.We've basically been looking at this toXML processing code, essentially.We've gone through, we've seen how we convert all those genome parametersso that they can be generated into tags,and we built up gradually from all the parts.Now, we have the ability to actually render out XMLwhich we can load in without error, importantly, into PyBullet.In this video, we've just completed the whole processfrom random numbers in the genomeinto XML that we can load into our physics engine.Now, we need to just tweak that a little bit,which we're going to do in the next video.Then, we're going to figure outhow to get the motors working in the robot."
}