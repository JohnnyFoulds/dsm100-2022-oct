{
  "course": "DSM100-2022-OCT",
  "topic": "Topics 5&6: Creatures",
  "title": "Lecture: Adding motors: creature.update",
  "url": "https://learn.london.ac.uk/mod/page/view.php?id=96301&forceview=1",
  "transcript": "[music]In this video, we're going to build the motorsfor the robot so it can start moving.First of all, we're going to have a quick reminderof how motors are going to work hereso that we know what we're aiming forand then we're going to write a motor type enum.Then we're going to do a motor constructor,which allows us to create a motor,so we're going to have a motor class to represent these things.Then we're going to write the get_output function on that.Then we're going to write a test scriptso that we can evaluate these things and see them running in real-time.First of all, reminder, how do motors work?Well, I don't mean motors in general,I mean the motors that we're going to have in here.Remember that we can use these functionsthat are available in PyBulletto set up the controls on the motor,and we're going to be using this velocity control,which means that essentially, you've got a motor,which can rotate in one dimension and it's on one plane.What we're going to be doing is we're going to be settingthe speed of the motor or the velocity.We're going to basically say,are you going that way or are you going that way and how fast.We're going to do that using a repeating waveform like a periodic waveform.We're going to have two types of waveforms,we're going to have a square wave or a pulse wave,which is going to essentially go from 1 down to -1,and it will essentially set the speed so the speed will start off at 1.It'll be maximum speed going that way and then at some point,it's going to switch maximum speed back to that way.That's the pulse wave, and then we're going to have a sine wave,which is similar, but it eases in and outso it doesn't suddenly switch to the other,it's going to slow down.It's more of a natural movement that which maybe will give a different momentumto the creatures as they walk in so that's why we're having two different ones.Those are the two motor types we're going to have.The first thing we need to do is go into the creature code,which I have over hereand we need to write a motor type enum.First of all, we import the enum class from the enum module.I'm going to define a class called motor typebecause this is going to make my code more readable later, this is why I'm using it,and it's extending from enum.It's going to have just two fields, one is going to be called pulseand that's going to be 1,and the other one is going to be sine and that's going to be equal to 2.That was easy.The next step is to write the constructor for the motor class.I'm going to define my motor class nowand it is going to have a constructor, so def_init.The constructor is going to take their self argumentso that it has access to its own stateand then it is going to have three more arguments,which are going to be the control_waveform,control_amplitude, and control_frequency.Let's just remind ourselves what we've got in the genome spec.The genome spec defines all the different propertiesthat we have in the genome, and there it is,and you can see that at the bottom there,we've stashed away three parameters for the motor.We're going to be using those and we're going to come back to those.Luckily, when I built the URDF class that also,there's the URDF being created there,URDF link, it actually receives these values as well.I've already got these values that I need,this data that I need to create my motors,I've already got that stashed away on the link, so that's good.We'll come back to that, though.We're going to have those three values from the links.Great.What are we going to do?We're basically going to make a decisionabout what type of motor we want to be.If the control waveform is smaller than or equal to 0.5then self.motor_type is going to be MotorType.Pulse.Else, it's going to be sine.Okay, great so that's good.Then the next thing is that we need to just stash awaythe control amp and the control frequency.We just do self.amp equals control amp,self.frequency equals control_frequency.Not much point in doing any tests for this yetbecause it's pretty straightforward.Now I can construct a motor.I could write a quick test just to make surethat it's not going to fall over at this point.Let's just write a very quick test motor,so def testMotor, and it's just going to say m equals creature.Motor,and it's going to pass it 0.1, 0.5, 0.5 self.assert(m).I'm just going to run the code to see if I've made any silly mistakes.Good, that's working. Great.Now back to the creature script.Next step is to generate the output from the motorso all it has to do is generate a periodic waveform.I'm probably going to use a library to do this, but so easy,there's no reason so def get_output,so get_output is going to be called by the simulation eventuallyto set up the speed of the motors over time and update over time.Actually, it needs to remember a phase.I'm just going to do self.phase equals 0 as wellin the constructor, so it has a phase.Essentially, I now need to do another test depending which waveform it is.If self.motor_type is MotorType.Pulse, then I do one thing.Let's just put the stuff in for now.Otherwise, if it's a sine, I'm going to do something else.If it's a pulse, what I want to do is if the self.phase is less than np.pi,then output equals 1, else, output equals -1.Basically, the phase has to be updated so that it changes over time.Let's do that self.phase = self.phase + self.frequency,that is a cheap way to use a frequency basically.The higher the frequency, the more quickly the phase gets updated.That's okay and if the phase goes over, basically, pi,then that's going to generate a -1,otherwise, it's going to be a 1.Now, I'm going to modulate this actually on 2 pi to make surethat it wraps around on 2 pi.I'll do Modulo np.pi * 2, that means the phase is going to go upwhen it gets to 2 pi, it'll wrap back around to 0 againso that makes sure that my pulse wave is going to be able to generate both types.Then if it's a sine wave, then I just do output equals np.sineand the self.phase, easy.That's it.Then I just return the output.Now I can write a quick test for that one as well.Let's go over here.I know I'm breaking the rules a bit here.I'm breaking the rules of unit testing, don't tell anyone.I wrote the code first and then the test.Then def testMotorVal.Let's just do this again, self.assertEqual,that should be a pulse 1 because it's got a 0.1 coming inso motor get_output should be equal to 1.Let's run that.Great. I passed my test.Perfect.I think I only got three. Yes, that's right.We've got a motor that works.Let's do one more test just to check the sine wave version.Since we've written all these tests before, no point giving up now.Oops.I'll just do a one that generates a guaranteed to be sinewaveso if it's 0.6 it should be a sine wave.I'm going to call get_output a couple of times.Okay.Oops.Sorrym.get_output.I did, the typing is all gone to pot.Let's just keep going now.I'm calling get_output a couple of timesjust to set the sine wave away from 0 and then hopefully,I can do self.assert the output is greater than 0.Let's try that.Good. That worked as well.It's got the same name.Let's call it motor value 2.Next, we run it.Great. That's passing as well.I've set it as a sine wave,and I've verified that it's generating a value greater than 0.I now have my motor class written.My next step is to get that integrated onto the creatureso that it can generate the motors for me.Let's very quickly go over to the creature and tell it to generate the motors.Where's the creature? There it is.It's going to have a new function called def_get motors.The thing with the motors is you need one lessthan you have expanded links if you like.Remember, the link graph, the first link,the root one doesn't have a motor because it's not connected to anythingbut all the other links do.You need one less motor than you have links.That's what we're going to do.We're going to say, for i in-- Let's start simple here.Motors equals that.For i in range, length of self.exp_links-1.That's going to go from 1 up to there, -1.Oh no, I'm sorry, not -1.We go from 1 up to the length of links, if that makes sense.I just need to do motors.append motor-- Let's do it properly, actually,so m equals motor, and I need the link as well.L equals self.exp_link(i) and the motor is going to be Motor (l.)and I need to pull properties off of the link.What are the properties called?Let's go over to the genome and check what the properties are called.They're called control_waveform, control_amp, control freq.That's sensible. Good.So (l.control_waveform, l.control_amp, l.control_frequency.That's my motor.Then I just need to append the motor to the motors.I think that is it.I've now got all my motors, and I can just do self.motors equals motors.I can even return self.motors.Now, what I might do at this point is put that assertion in.Remember, I had an assertion up here.Just to check that I've called expand links first,and then just say call before get_motors.I've done that.Also, if self.motors is none,only do this if self.motors is nonebecause no point in regenerating them every time.Also, I'm going to be repeatedly coding thisevery time I want to update the motor,so I don't want to have to do it like that.Then I just need to fix that.I need to do self.motors.I've already done that. Great.My creature is ready to go.Now I can call a test on it.Let's go test creature.I'm going to do testCMotor.This is basically testing if I create a whole creatureand get the motors off that so let's just grab some code from up here.That is easy, so C equals creature.Creature,gene_count equals 4 and ms equals c.get_motors.I need to do c.get_expanded_links.L's equals get expanded links,and I can just verify that the number of motors is one lessthe number of expanded links.Self.assert equal length of ls-1, length of ms.That works?Yes, so it's basically checking that I have one less motorthan I have expanded links because we've got the root link we don't want,so let's run the code and check if it crashes.It looks like it got a little problem there.Attribute error numpy, has no attribute l motors.L dot, okay, because I put a dot here by mistake.Back to creature.I was going too fast.Where is it? Get motors.There it is.Go back to the test.The test is good and that it runs the code and sees.That's passing that test.That's great.I've got some motors.They seem to work and generate a sensible output.I could do more tests, but that's good enough for me.My next step is to end this video because I'm happy with where I've got to.In the next video, I'm just going to write a very quick test script,where I basically generate a random creature,and then chuck it onto the screen, then move its motors.That'll be our sort of whole genome development process complete and tested,and will be ready to then implement the actual algorithmwhich evolves these things.Let's do that.I'm going to jump off the screen nowand just summarize the end there.So just in this video, I've just been building out the motor implementation.In the next video, I'm going to finally just builda test script to test the motorsand see if we can get them to move a creature around on the screen."
}