{
  "course": "DSM100-2022-OCT",
  "topic": "Topics 5&6: Creatures",
  "title": "Lecture: Multi-process evaluation",
  "url": "https://learn.london.ac.uk/mod/page/view.php?id=96319&forceview=1",
  "transcript": "[music]In this video, we're going to make our simulation run much faster.In summary, we're going to start outby just saying what the motivationis for making it run faster in case that's not obvious,and then we're going to gothrough the steps of preparing the simulation.Now, I'll just say in this videothat I am not handwriting every lineof code because it's not strictly on topic in a sense.It is quite complicated, and I don't want to spendtoo long writing every single lineof code, but I'm going to explain every line of code.How about that?First of all, the motivation is that it's too slow.What does it mean to say it's too slow?When you're running a GA, you're going to have to evaluate thousands,and thousands, and thousands of individuals.Let me just illustrate what kind of problemwe have in here by running an evaluation.Here's my test code.Let's put the population size up to 100, right.Oops.This test code which we saw before is going to basically evaluate100 individuals, so I'm going to do that now.You can see that is chugging away.This is all running on the CPU, so it's not GPU-acceleratedlike a neural network, unfortunately, although there is talkof PyBullet being able to use CUDAat some point but not yet, I don't think.Anyway, so that's how long it tookto evaluate 100 individuals in series.What it's doing there, just to illustrate,is you've got a population of individuals.These are all the creatures in the population,so we give those a C for creature.Then we've got a single simulation like this,and what we're doing is we're basically, in turn, going in that one,putting that in the simulation, and that one, that one.Okay.You get the picture, right.We do each one individually.What we're going to try and do in this video is we're going tobasically say,\"Actually, I'm going to have multiple simulations and they're goingto run in parallel because my machinehas multiple cores, so it can run computations in parallel.\"The way it's going to do that is we're basically going to say, \"Right.Okay.Put that one in there, that one in there,that one in there,\" then run it.Then we're going to load them up again.We're going to say,\"Right.Put that one in there, put that one in there,\"run it, and we go through it.Imagine, if you've got 100 of them,you're just going to do like four at a time.You going to have four, four, or however many cores you want to use.I think I might have six coreson this machine, so yes, that means I can do that.How is it going to work?First of all, we've got to prepare the simulation class.The first problem, if we're going to be runningthe simulations in parallel is that at the moment,each simulation has the same file name.They all basically write to this file called temp.urdf, don't they?Imagine if they each write to temp.urdf in parallel,so they're going to overwrite each other's files.That's basically a disaster because they'll all have different--It's going to break the firewall possibly.It's just a disaster.How are we going to solve that?What we're going to do is we're going to go backto our simulation class, which is over here,and we're just going to set it up so it requires a unique ID.We'll call it sim_id, and we'll set it to zero initially.That means that all the teststhat don't pass it, that number will still pass.The way I'm going to use that number is I need to store it,so I go self.sim_id = sim_id.It's stored.Then what I can do is in run_creature,this line here where I specify the file name,I'm just going to use the sim_id as part of that file name.I'll just do + str[sim_id] + .urdf.That should do it.Oh, so it's self.sim_id, isn't it?Self.sim_id.That should mean that it now creates a unique file namefor its ID each time, so it can stand.Let's just check that.I'm going to reduce the number of things just down to here.This one should write all the files to something called temp.You can see there, that's the temp.It's now writing temp0.urdf instead of temp.That's good.Each sim has its own unique file name,which is great, so it means I can run themin parallel without them clashing with each other's files.Great.They've done that.The next step is to create a ThreadedSim class,so let's just do that.It's basically going to havea constructor which creates multiple sims,and it's then going to havea static function for running creature in simulation.I'll explain the reason we need a static function,not a stateful function for running the creatures in simulationin the pool mode when we're doing it with multiprocessor stuffis that that's how the pool object that we're going to use works,basically, so we have to do it like that.How are we going to do this?Let's just go in and createa ThreadedSim class in the simulation code.We're going to create something called class ThreadedSim[]:and it's going to have a constructorwhich takes self and the pool_size,which is going to be the number of things in the pool.That's how many CPUs it's going to use.You could call that CPU count or something if you want, but whatever.Anyway, so that's that.What are we going to do?We can doself.sims = [Simulation(i) for i in range(pool_size)].That's it.That just essentially fills upa list with a set of simulation objectseach of which has a unique ID up to the number of pool_size.The next thing is I need to writea static function which allows me to evaluate a creature,so I'm going to do that here.Remember, the static functions are functions which we don't needto create an instance of the object in order to run thembecause they have no state,they don't rely on the state of the object.They don't access self basically.This one's going to be called run_creature--or let's call it static_run_creature,static, so it's really clear what it is.Oh, run_creature.We need to pass in everythingthat it needs to run a creature in simulation.What does it need?It needs a simulation, it needs a creature,and it needs to know how many iterations to run for, right.That's it.All it needs to do is say sim.run_creature,and it's going to pass it the creature,and it's going to say iterations like that.Actually, what it has to do as well is it has to return the creaturebecause in threaded mode, in multiprocessor mode,it's going to create a copy of the creature so that it passesby value rather than by reference.We need to make sure we return that so we can get it back.It doesn't seem to like that for some reason.Oh, because I've got a full stop there.There we go.Right.Okay.Good.That's that.That's now ready.It's got a static function.This is where it gets gnarly.What we're going to do next is we've got to figure out a wayof creating the arguments that you pass into a pool.When we create a pool of processes,it needs all the data that's required to execute multiple threads.In this case, let's say we had four simulations,what we're going to need to do is pass it those four simulations,and then the four creatures that it's going to runin those simulations, and also the number of iterations.What each thread or each process is going to do is it's goingto run static_run_creature,so it's going to need a simulation, a creature, and an iterations.What we'll do is somehow take that, which is the input to all of thisand which is basically a populationof creatures and a set of simulations,we've got to reorganize it into-- We've got iterations as well.Let's just pop that in as well, iterations.We're going to have to organize it like this.We're going to have to have a simulation,and a creature, and a number of iterations.For each process, say we had four of them,we'd need four of these, so we'd have to do SCI, SCI, SCI.That's what I need to prepare.That's my pool arguments.I have to prepare that as a list of lists.It's worse than that.Actually, you can tell I've got six.I haven't done all of the creatures there, have I?I've still got two hanging over.I'm going to have to actually createtwo pools, and I'm going to run those in series.The first pool will run on four CPUs and do everything,and the next one will do the other two.Imagine if I had 100 creatures I needed to analyze, to simulate,then I'll have to do it in sets of four or six or whatever.This data here that we can see, that gives me one pool's worth,but I need that for every pool, right.In this case, I would arrange it so I don't need an extra two.That would be a big list like that.A list of lists.Then, I'd need to create another one,which is-- got S, C, and I; S, C,and I for the final two, in the casewhere I've got a population of six, right.That's what I need to create that data structure.It's a little bit prone to error writing this kind of code.I don't want to go through a full unit testing process,so I'm going to cheat and use the classic British TV show,which is called Blue Peter,where they used to say, \"Here's one I prepared earlier,\"when they were making somethingon the show, and then they'll pop out thisreally complicated thing.That's exactly what I'm going to do.I'm going to start by saying I'm going to havea function called eval_population,which takes as an argument, a population, and a number of iterations.Then, the first step in thatis to create this rather complicated data structure.That's what that code there does.Let's just chuck that in, and just verify that it's working okay.Oops.Put that back there.It needs to be stateful.It needs access to the set of simulations we created.Right.Just to talk you through it, this is the big mega arraythat's going to store all of the sets of arguments, sets of sets.Then, this allows me to do the double iteration.The inner loop is creating basically each of these, in turn.That's your inner loop.Then, the outer loop is creating the whole lot.The outer loop is creating the whole thing.That's all that block of code is doing,it's just basically creating allof those objects in a nice list of lists of lists.At the end of it, pool_args contains all of that stuff.Great.Now, I've got my arguments ready.The next phase is to actually generatethese process pools and run them.I'm going to go to that.We iterate over the sets of pool_args and create one pool for each set.Each of these sets.Remember, one set that I'm talking about here is like that.I'm going to create a pool that's goingto run all of those creatures,and then another pool that's goingto run all of those creatures.Again, I'm just going to grab the code herebecause it would take too long to write itand test it properly, and I've already done all that.Here we go.It's not that bad.We can grab that.Now, let's go through it.First of all, what we do is we create an empty list,which we're going to store the results inbecause remember, I was saying that it will basically create a copyof the creatures and we need to get that copy back and store it.First of all, I need to get this pool imported.That is from here, multiprocessing import Pool.Okay.Right.Back down again.Yes, where were we?Sorry, something's gone wrong there.Let me just get that back.[silence] Okay, that's it.We create an empty list of the creatures called new creatures.Then, we're going to iterate over the sets of args.For each pool's argument set, we create a new pool.A pool is this thing from the Python APIthat allows us to easily run a set of processes in parallel,and the arguments would dictate how many processes there are.We call this special function on the poolthat we just created called starmap, which sounds cool, right.It goes over the arguments and calls this function on each setof arguments, so static_run_creatureis run on each set of arguments.Now, we know that static_run_creatureis our function that we just wrote,which is up here, and it takes a sim,a creature, and a number of iterations.That's exactly what we're going to need to pass it in here.That's why we built that data structure.We don't need to print that.Then, it just extends the list of creatures with the return from that.It'll return the number that you pass it.The first time, it'll return fourin this example where you've got six and four.It'll return four the first time, and two the second time.All of those creatures that come back--It's going to return creatures,and we're sticking all of those backonto the new creature's array.At the end, actually, just for interest,we're printing out the distance that they traveled.Finally, we assign the resulting creatures onto the population.We replace its previous set of creatureswith the evaluated set of creatures.Final step is with that code to now writea quick test code, and we can then comparethe speed to see if it was all worth it, so def testProc.I'm just going to do all the same stuff here.I do like this.I don't need a sim.I'm going to dotsim = simulation.threaded sim(pool_size = 4).Then, all I do is I do tsim.eval_population(pop, 2,400).That should do it.You can see.I can then do the same stuff I did here and the same test.Let's compare it.Let's put 20 in there and 20 in there.We'll run the first one, see how that one goes.This is the non-threaded one.Let's just see that again.That was the non-threaded one.Then, now let's run the threaded oneon 20 to see what the difference is.[silence]Hopefully,you can see that that was significantly faster.If I increase the number of threads to the pool_size to say, eight,I think, I'm not sure how many CPUs I've got,you see it's that much faster again.That's pretty quick.I've got another machine that we'll use later,which definitely has eight cores on it,and it's got a more powerful CPU, you can see how fast it runs them.You can see, suddenly,it becomes viable to run thousands of these overnight.You can run it for a long time and see what comes out.You'll get a really good searchof the space when you have a big population.That suddenly becomes realisticbecause it's six times or eight times as fast.That's probably enough of that.Let's summarize.What we've been doing is just quickly makingthe simulation multi-processor capableso that we can evaluate multiple creaturesin parallel and have a much faster genetic algorithm basically.The steps we went through, we prepared our simulation class,so it would be able to have a unique file name.That was easy.Then, we create this ThreadedSim class,which had the appropriate stuff it neededlike a static evaluation function,and then all that fancy code to set upthe arguments to pass into the poolusing the built-in processing features,multi-process features of Python.In this video, we've been acceleratingour genetic algorithm with a multi-fold increase in speed."
}