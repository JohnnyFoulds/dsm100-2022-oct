{
  "course": "DSM100-2022-OCT",
  "topic": "Topics 5&6: Creatures",
  "title": "Lecture: Gene to graph - implementation",
  "url": "https://learn.london.ac.uk/mod/page/view.php?id=96285&forceview=1",
  "transcript": "[music][music]-In this video, I'm going to take the pseudocode algorithmthat we saw in the previous video,and I'm going to convert it into Python code.In summary, we're going to talk about the flat links part of that algorithmand then we're going to get into the expanded links partwhere we dig in and really expand out that graph.We're going to deal with the unique link names problemas we go along,and we're going to be writing tests as we go too.First of all the flat links.Now, what I want to do isI'm going to use a test to say what it is, I'd like to be able to do.Here, I've got my test genome file here, and I'm going to write some new tests.I'm going to do test flat links.This is what I'd like to be able to write.That's one I'm doing with this test.I'd like to be able to say that links is a set of thingswhich I'm imagining I've managed to pull out of a genome somehow.I'll do genome.genome.URDFlink.It's going to have a name,it's going to have a name variable,and that's going to be A for the first one,it's going to have a parent name,which is going to be none.Let's make that actually none for the first one because it's the root.Then it's going to have a recurrence,which is going to be one for that one.This is what I'd like to be able to write.It's not going to work yet, because I haven't defined that object yet.I'm going to have the rest of them so B, C, and D.That's going to have parent A,that's going to have parent B,C, and then that remember, C has a recurrence of twobecause we repeat that part of that graph, and its subgraph twice.There we have it.I'm just going to assert thatself.assertisnotnonelinks.That should do it.I'm going to run that test.I get an error, which is,genome has no attribute URDF link.That makes sense. I haven't defined that class yet.I'm going to go ahead and define that classand then we should be able to pass this test.Let's write the minimum code to pass that test,which is to write a urdf link class.Here's my genome means genome.py now,and I'm going to put a new class into genome.The same level as the genome class,gn is going to be called URDF link.It's going to have a constructor,which takes as its argument itself,the instance of the object plus the parent name,and recurrence level,and it's just going to assign those.It's going to say self.name = name,self.parent name = parent name.self.recur = recur.That's the basics.If you're not familiar with object-oriented programming,basically, what I'm doing is I'm creating a wrapper,which I can use to contain all the data, I need to represent a link.The idea is, eventually I'll get that genome,which is the list of floating points.I'll pass it through the genome specto convert it into numbers in the correct ranges,and then I'll extract out these URDF objects.Now I don't want to do that. But yet, I just want to write the algorithmthat basically expands the graph for now.I'm going to assume that I can already do that.I've ended up with these links.That's what I'm doing here.I've got this wrapper that can contain the relevant parts for nowof what a link is.It's going to have a parent name, and a recurrence.I should be able to now run this code where I essentially use that classto create a bunch of linksto represent the graph we've been looking at.Type object genome has no attribute.URDF have link, so it's not inside genome, is it?It's actually just inside the module.That code where it says genome.genome that's digging into the genome classinside the genome module,but only to do that because it's at the top-levelinside the genome module, isn't it?Because I just put it at the same level as the genome class.Hopefully, that'll work.Great. I'm passing that test now.My next step is phase two,which is where I actually do the recurrence,and I expand these basics, flat links into the expanded links array.I've got my flat links,which is if we remember back to the drawing,so that's my flat links up there.I need to figure out how to expand it into the expanded linkswhich is coming down on the left there.How do I get it into that?This is where the recursive algorithm comes in.I'm going to write a new test for that.Def test expandlinks.This one is going to start with the same links here.It's going to create an expanded links array.I'm going to just say,genome.genome, expand links.I'm going to pass it the parent,which is going to be what link zero,so it's going to pass it the top-level one.I'm going to pass it, the flat links,and I'm going to pass it the expanded linksbecause that's what we need.That's the basic function signature that I had in my pseudocode.What does that function do?Well, let's go into genome and start writing it.That's genome.genome.It needs to be in the genome class. Go up here.This is the genome class.I'm inside here. It's going to be another static function,because it doesn't depend on the state of the genomestatic method,and it's called def expandlinks.It takes as a parameter, firstly, the parent link,the flat links,and the expanded links.Now, the first thing it does if we go back to the pseudocode is this.It basically finds the children for that parentbecause we want to know, okay,what are all the links that connect to this one?What we can do is we can just use a list comprehension to do this.We do children = l for lin flat links,if l.parent name is parentlink.name.Why does that work?Well, so remember flat links containsflat links contains all the link types, the sort of A, B, C, and D.What I want to do is I want to go through all of that and say,give me all of the links from there that have the parent a,in the first instance.I'm filtering that list of all the linksdown to the ones that have the parent that's coming in.The incoming parent is called parent link.I'm doing filtering for things that have the nameof parent name of parentlink.name.That gives me the children of that parent. Great.The next thing I need to do, according to the pseudocode, isI need to iterate of the children.Inside there iterate the recurrence level,and then add copies of those childrento the expanded links array, and then dig in.Wow, okay. Let's implement that.Hopefully, actually, let's just see if I can write test here.What I want to do is assert that at the end of this,I'm going to have six links, so length of expanded links,I'm going to say that it's sixbecause if you remember that we need to end up with sixbecause that's what it looks in the diagram that I worked out here.Up there, you can see I've got A, B,two C's, and two Ds,that's wrong so there's six links in the expanded links array.That's what I'm going to do with this test.Let's run it.Zero is not equal to six.There's nothing in the expanded links array yet.I need to go ahead and implement that.Let's do that.For C in children,for A in range,c.recur.Iterative of the children iterate of the recurrences of each child,make a copy of the child.Now, in order to copy an object,what I'm going to do is import the copy module,import copies.I do that at the top of the script there.Back down again,and I do so C copy=copy.copyc.Remember, C is the child that I've got.I'm making a copy of it.I'm going to expand it links.Append c copy.Then I dig into the tree. I dig into the graph.I'm going to say, expand links, and I'm going to pass it C.I'm going to pass it the flat links,and I'm going to pass it the expanded links.Now, I don't pass it the copy of C because it's fine.It just needs the original flat link version.That's going to help us out in a minute as wellwhen we get to this unique link lame problem,which I'm going to deal with in a sec.Expand linksnow saying that it's going to give me an error thereso I need to just put the namespace inside the genome class,cool, expand links on that.Let's save that.That is the basic implementation, and see what we get.It's now saying, I've got an error which is five is not equal to six.If for some reason I've only got five linksin my expanded links array,after I call that function, it should be six.Now, why is it only five?If we look at the code,we never actually add the top-level parent.We send in this quarter,we start off by bootstrapping it by sending it the parent,the root node, which is A,but it never actually adds that to the arraybecause it only ever adds children.The only things that ever gets added to the expanded links arrayare the children.The original parent that comes in, never gets added.What I can do is I can just do that up here.I just put it in, started off with the parent of the root node there.Cool. There we have it.That's fine and no problem.The next thing is,the problem is thatI've got this thing with six links, and let's just check what the names arebefore we carry on, and then we can see what the problem is.I'm going to just going to donames = (l.name for l in exp_links).I'm just going to print the names out,just so we can see them.Let's just run that.Where are they? Yes, there we go.I'm just going to get rid of the other printoutbecause I don't want that.That's there. That's confusing me. Good.Let me get out of the way.What have we got?These are the names of the links that I've created,and that's what we expect, that looks good,because we wanted that.We wanted A, B, C, D, C, D and that's what we got. Great.It's working, but the problem is in the URDF file,every link has to have a unique name.I can't have two links with the same name,because I think it would be an invalid file,so it probably won't load it.Also, it means then I can't then link to it,because if you look at this structure here,you can see whilst they're both kind of seem to be called C,if I'm building that structure,how would I know which C I'm going to be linking toif they're both called C?Actually, they're going to have to have unique names,and that means I'm going to need to pass that unique name through,so I'll correctly structure my URDF link objects.I'm going to have to expand on this function a little bit.All I'm going to have to do is, I need to have a parent link,and I need to have the parent linkunique parent name.I'm going to add that.What it's gonna do is, yes, you're going to know which link it isbut you're going to use the unique name to link toinstead of the original one,and that's going to make it work.First of all, I see you need to douniq_name =c_copy.name +and then I'm going to use the length of the expanded links arrayto figure out a unique name,expanded links.Now it can't be an intercom, add an [?] to a string,so I've turned that into a string.That'll give me a unique name.That's great. I'm going to do c_copy.name = uniq name.The problem is, if I'm now digging into the tree,and I'm linking to the original name, which is like A, B, or whatever,but I've now renamed it a zero,that means I'm going to lose that link,or I'm not going to know what I'm going to link to it.I need to pass this unique name in to the expand links function.I'm going to do unique name,so it's going to get the unique name.I need to fix it so that the child-parent name,so c_copy needs to know what its unique parent is.This is a little bit complicated, but trust me, we're nearly there.So c_copy_parent_nameis actually going to be this one coming in, uniq_parent_name.That way, it allows me to pass those through.Let's just save that and then run it, and you'll see what I mean.Excuse me, I did make an error,expandLinks missing 1 required positional argument.Oh yes, now in the test,I need to pass it in that uniq_parent_name as well.That's fine. Let's just pass it a uniq_parent_name.Because it's the first one, it can be just that.That's fine.The first time I call it, it's just going to be the root nodeof which there's only going to be one,it should be fine.Let's have a look. Now, you can seeI've got A, B1, C2,and then importantly C2 does not have the same name as C4.I've got two C prefix names.The question is did my little trickery to make sure thatthat unique name gets passed through is the linker name,is that working as well?Let's see what we can do there.I'm going to make a string here.I'm going to do, (l.name+\"-parent-is-,\"and then I'm going to add, +l.parent_name,so we can just verifythat the parent name looks correct as well.Let's run that.Let's have a look.Oh, can only concatenate str (not \"NoneType\") to str.It's saying that somehow, parent name is none,because, yes, that makes sense.If we look up here, we can see the parent name is none.When you're making videos,I don't always like to leave them perfect.I'm going to leave that error in and let you think about that.You can see when I run this, I'm getting this problem.It's saying, can only concatenate str (not \"NoneType\") to str.I'm trying to stick together.I'm trying to make a listthat tells me what the original name is of the link,and what its parent name is.The problem is, you can see here,the first parent name,I'm setting to None,so I try to concatenate None,and then a parent name.I'm going to just set that to current name,let's just put None as a stringso that it's really clear that that is what it is.Let's see what we got now.'A-parent-is-None', that makes sense,'B1-parent-is-A', that makes sense,because B1 is linked to A.'C2-parent-is-B1',so that makes sense because C2, our first C that we've createdis connected to B1.Then it says 'B3-parent-is-C2','D3 connects to C2', that's good,and then 'C4 connects to B1', that's good,because we've got a unique C there,so C4, I've got another C, and that's also connected to B1,hasn't come up with a weird name.'D5-parent-is-C4'. That's the other one.If we were to draw this out,if I just pull out my pen and we draw this out,we can now show what the actual names are on our graph here.We've got one, two, three, four, five, six.What I've done with these unique names,is I've got my A,and I've got B1and then I've got D3, C2,C4,and is it D5 the last one, yes, D5.What I've done is I've connected them up like this.You can see, 'A-parent-is-None',so that doesn't have a parent, that's fine.'B1-parent-is-A', so that's there,'C2-parent-is-B1', that's that one,and then it goes, 'D3 is C2','C4 is B1' yes, good,and then \"D5 to C4'.Perfect. Okay, I'm happy with that.My little trick to create unique names, then pass them through,the recurrence is working. Great.What I want you to do, I'm going to set you the taskof run some more tests for thisand just verify that it's definitely workingby passing in some different trees, so by hand, you can pass the trees.Have a look at what comes out from this algorithm,and see if it's correct.Let's jump back to the slides and do a quick summary.Where is it? There it is.What we've been doing in this video, we've just been working throughand putting in a placeholderfor the flat links generator at the moment,so we just manually created these URDF link objects.We've been testing out the expansion function,which takes that flat graph and expands it outusing the recurrence relationships into an expanded graph.We encountered this problem where we need unique IDs.I showed a little trick to pass those through,and we did a bunch of tests, and we verified the namesand looked at that in great detail.Hopefully, that's really clear to you now.I want you to go and write your own tests now,so you can test it with some different laboratoriesand see if it works.In this video, we've just been working on implementingthis recursive algorithm to expand our graph."
}