{
  "course": "DSM100-2022-OCT",
  "topic": "Topics 5&6: Creatures",
  "title": "Lecture: Generate a genome",
  "url": "https://learn.london.ac.uk/mod/page/view.php?id=96278&forceview=1",
  "transcript": "[music]In this video, we're going to start codingand start building out our genome class,which is going to allow us to generate random genomes,and also it's going to have a descriptive capability as well.In summary, what I want to do is,first of all, create a genome class.Then I'm going to generate a gene at random,so a random set of numbers.Then to generate a random genome,we're going to differentiate between those two terms clearly.Finally, how to create a genome specification,which allows us to say what the different bitsin the genome are going to be used for based on the parameterswe identified in an earlier video.The genome class, now remember,we're doing test-driven development here.Let's jump over to this.What I'm going to do is create a new file,and it's going to be called test genome.Test_genome.py.Save that as tesT_genome.py.What this is going to do is it will contain testsfor the genome class that I haven't written yet.Remember, I'm doing strict test-driven development hereso I'm not going to write any code until I've written a test that fails.Remember, we do class genome tests,and it needs to extend on unittest.TestCase.Then we define a function called-- let's do testClassExists.[chuckles] How about that?I'm basically going to import genome as-- so genomedoesn't exist yet, but I'm going to import it anywaybecause it's a failing test, and that's fine.Self assert is not none.It's not none.Genome.genome.That's it, that's my failing test.You'll get the spirit of test-driven developmentas we work through it. Let's run this.That's the minimal test that I need to write for a fail,and I hit play.Import genome, no module named genome.I can resolve that.I'm going to create a new file.I\"m going to save it, I'm going to call it genome.py.Great.Save that.Let's see if I can pass my test now.Oh, I forgot to actually run the tests.Unittest.main.Let's try again.My code was even too minimal.Attribute error, module genome has no attribute genome.Good.Failing tests.That's what we need.Then we write the minimal code to pass the test.It's going to have an attribute genome and that's it.Hopefully, they'll pass the test.Okay, good.I've passed my test but I haven't got anything very useful,but this is how test-driven development works.The next thing is I'm going to writeanother test which I can fail.I want to make sure-- remember,we're trying to basically generate a random genome here.I want to do is test RandomGene.I want to test that random gene exists.Test, assert, is not none.genome.genome.gene, get random gene.I'm going to call it get random gene.The function I need to define is called get random gene.Let's run that.You'll see now I've got a failing test because object genomehas no attribute, get random gene.Let's do that.Def, get random gene.This one is going to be a static function.It doesn't rely on the class having anystate so there's no object required.I can write a hint here.I can write static.I can do @staticmethod, like that.That says, this is a static method.I don't need to create a genome object before I can use it.It's just sitting there.It can just return.It's a bit of a programming lesson where we're going.Why not?I'm passing that test.I need to write another test to make sure that it actually does something.Let's do this, test random gene, not none.Okay.Test is not none, genome get random gene.I'm actually calling it now.That should give me a problem.I've now got one failed test again.I need to go back and make sure it doesn't return none.I'm going to return an array now.We're building up gradually, this is the process.I'm now passing that test.You keep going.They're really facile tests, but they basically allow youto evaluate your code as you write it.We'll get a bit deeper once we get into it, but that's fine.Get random gene not none.Get random gene has values.Assert is not none, get random gene.Let's just get a bit more complicated,gene = genome get random gene.I'm going to assert that, gene 0 is not none.Fine.I'm going to jump ahead now.I'm going to go straight for itand I'm going to do import Numpy as np.My gene is going to be return gene = np.random.random, for i in range.Let's just put-- and then we can return gene.That's a list comprehensionwhere I'm going to iterate through this loop,which is basically going from zero up to nine.In each point in the loop, I'm going to be generatinga random float using np.random random and then I return that.That's going to give me a random gene.Hopefully, now I should pass that test.I can even just print out my randomgene just to verify what it looks like.That's what I'm after basically.A set of random numbers in a gene.Now, the final thing I'm going to do is add a parameter to the function.I'll do another test.Test random gene length.I'm going to now say I want the random gene,take a length parameter, which is going to be, say 10.I want to get back the number that I asked for.I'm going to self assert = in this case.I want that to be the length of-- I'm going to assert thatthe length of gene-- Oops, let's just do it from scratch.Self.assert = length of gene is 10because I asked for a length of 10.Actually, let's do length of 20 because I know it'll fail that.20.Then we run that.I'm running five tests, I've got one failing test.Get random gene takes 0 positional argumentsbut 1 was given.It doesn't take any positional arguments so I'm going to say,now, I want you to take a length parameter,and that's going to get passed into here.Now that test passes, but now you can seetwo of the other tests have failed.We need to go back and fix those other tests.In my regression testing, you can see I'm now failing.That's because I'm not passing any numbers here.I can pass those tests by just passing in numbers.Hopefully, yes.All my tests are running.I've got my random genome generator.That was a little bit over-complicated,because I was doing my unit test approach,but it does mean I've got a nice test re-developing here, which is great.The next thing I need to do is, I've got random gene,I've got a genome class, I need to do random genome.Just to be clear, the difference between a geneand a genome is that a genome is made up of multiple genes.The concept we're going to use here, remember that list of parametersthat we designed earlier, which is over here,remember that list of parameters, the idea is that a geneis going to encode this set of parameters.Effectively, each gene represents a linkor if it's got a higher recursion, multiple links.Then the genome is a set of genes.We have multiple genes in our actual creature.That's the idea.What we're doing now is we're making a genomewhich is essentially-- has multiple genes in an array,but they're really just NumPy arrays underneath the hood.What I'm going to do is, first of all,I'm going to write a test to verify that I'm getting NumPy arraysso testRandGene is NumPy arraybecause I want everything to be NumPy arrays.I'm just going to pull out gene and self assertI'm going to say type of gene.Now, I can't remember what the type of NumPy arrayis so I'll just quickly check it here,as np, and a = np.array 1 2, 3.Type of a.I need to verify that that's what I'm looking for.I need to make sure that I'm getting NumPy arrays back.I'm just showing you my practices, how I do stuff.You can't remember every possible thing.Gene equals self is type of gene is going to be equalto numpy.ndarray like that but we canactually np because we imported it as np.Let's run that and put self in.Let's run that.Name np is not defined because I have an imported NumPy,so let's just important NumPy to the tests so we can access it.Let's run that again.One test failed \"list,\" so at assert error,we've got a list but we wanted a NumPy array.Let's convert that to a NumPy array, and that should be easy.We can just do np.array, wrap that, like that.Done.Minimum code to pass the test, done.We'll test the passing.Now, next step is to get that genome.I'm going to say def testRandomGenomeExists.I just do genome = genome I can't call it genomebecause that's the name of the importso let's call it data because genome.Genome.get_random_genome.Let's say, you have five genes.Now, let's just assert thatself.assertIsNotNone (data) basically.Let's run that.It crashes because genome doesn't haveget_random_genome yet so we're going to just do that,gene_count.For i in gene_count.We could actually do this with less comprehension as well.Let's just do that.We can just do genome= get_random_gene.Let's do gene_length,gene_count.get_random_gene on gene_length for i in range(gene_count).Okay, good.I'm going to put this as a static method as well.That can be a Genome.genome get_random_gene, gene_length, da, da, da, and then return genome.Hopefully, we can pass that test now.TypeError, get_random_genome, missing one required positional argument,gene_length because I need to pass it a gene_length.Let's say 20.I'm passing that test.I can now generate a random genome, so we're making good progress here.This is really that test-driven development approach.Moving on.What's next?I've got random genomes.What about genome spec?Now, this is where it gets a bit trickier.What I want to do, I'm going to be a bit naughty,I'm going to break out from my test-driven developmenta little bit here because I want to just write out what a spec is.Let's put a little test in so we can just say, def testGeneSpecExists.I'm going to do spec = genome.Genome.get_genome_spec-- gene_spec actuallybecause it's really a gene, not as genome.spec and self.assertIsNotNone,just copy that, spec.We can run that just to verify.Failing test, def test I can't evenWhat's the problem?Invalid syntax because I forgot my colon again.There we go, so type object Genome has no attributeget_gene_spec so let's write that.@staticmethod, def get_gene_spec,and return a dictionary.That's now passing that test.I'm going to go into a bit more depth here.I think I'm going to skip to the next video to do thisbecause I've been rattling through just making basically,a list of random numbers and could have done it in one line,but I wanted to show you that test-driven development workflow.In the next video, we're going to come backto this and do the gene spec.Let me just jump to the summary just for completeness.In this video, we've just been working throughbuilding up some of the code,the underlying algorithm to generate that random genomeand random genes, and doing it in a test-driven way.That's it, see you in the next videowhere I'm going to be doing the gene specification."
}