{
  "course": "DSM100-2022-OCT",
  "topic": "Topics 5&6: Creatures",
  "title": "Lecture: Crossover and mutation",
  "url": "https://learn.london.ac.uk/mod/page/view.php?id=96328&forceview=1",
  "transcript": "In this video, we're going to be implementing the various genome operations which allow us to generate variation in the population.We're going to be doing crossover, point mutation, and grow and shrink mutation.Here's crossover.The idea is that basically we take a bit from each parent and we use that and then combine that together to get the child.We've seen that before, so let's just see if we can simplify that a little bit.What I'm actually going to do here is I'm going to take the two parents and I'm only going to crossover where the gene boundaries are.Remember that we break the genomes into genes where each gene defines a link so the idea with that is I'm going to take say, the first link from the one parent and then the other two links from the second parent so it combines the morphology a bit more directly rather than crossing over in the middle of the genes.We'll do that just to simplify things a little bit.Let me just slide my pen away.What we're going to do is write a test, of course, so we'll go into our test genome code and we're going to do testXO.Basically, what I'm going to do is I'm going to do it with raw numbers because rather than creating random genomes and all that, it's a little bit easier to test what's going on if I just hard code what's in the arrays.I'm going to, first, create two NumPy arrays like that and one's going to be 1, 2, 3, and that one's going to be 4, 5, 6.Actually, maybe let's put three genes in there just to make it really clear, 7, 8, 9 and then we'll do 10, 11, 12, and 13, 14, 15 in that one.Then 10, 11, 12, 13, 14, 15, 16, 17, 18.There we go.We just got two NumPy arrays each of which has three genes which you can see there and I'm going to get those and then see if I can crossover.G3 is going to be genome.genome.crossover g1 with g2.That's the idea in a single point crossover so we're just going to go ahead and do that.It's going to be a static method because it's going to be easier to test that way and it's basically stateless anyway so we don't need it to have any state.We're going to pass g1 and g2 in.The first thing we need to do is choose a crossover point.Crossover is going to np.random.random integer which is up to the length of g1.We're going to, first of all, pick a random point across the genes in the genome 1.Then I'm going to say g3 equals np concatenate and I need to pass that a tuple.I'm going to pass it g1 and g2.Normally, that would just stick g1 and g2 together and make something out of the two but what I want to do is take only a certain bit of g1.I'm going to take from zero up to crossover and then on g1, and I'm going to take from crossover to the end in g2.That's simply it and I can just return g3.Now, the only thing is that it might be the case that g1 is longer than g2 so I might have ended up with an index which is beyond the bounds of g2.What I can do is I can just double-check that.I can say if XO is greater than length of g2, then XO can just be set to length of (g2)-1 like that so I get a bit of g2 and that's it.Then what I do next here, yes, just do the concatenation.I return it, so let's run the test, and maybe I can do an assertion to say, self.assert equals-- and I might check that the length of maybe g3 is equal to the length of g1 just to see if it's working properly.It's a very simple test.We could, as usual, write more tests if that's what you wanted to do.Let's run it.That test is passing, that's great.I'm happy with that.I could even just print out the results just to see what's happened.Print g1, g2, g3.Let's just print them all out and see what we got.So what have we got?There's g1 so that's the first three, and then the second three in there.You can see I've then ended up with some of g1, which is the 1, 2, 3, 4, 5, 6, and then the end of g2, so that worked nicely.Let's just run that a few more times so we get another variation.There we go.That one I've ended up with the whole of g2 so obviously crossed over at the end of g1.That's interesting, isn't it?You can see that's working pretty nicely.If I wanted to be really sure, I can always just do it 100 times and check if it's going to crash which is something I would do just to stress-test the code to see if I've done anything stupid, basically.There we go.Ran it 100 times nothing went wrong.Great, and it's fast.That's crossover done.Next up, we have point mutation.Simply put, point mutation is when we add or subtract a value from a locus.What we're going to do here is go back to the code again and write a test.I can do def test_point and I'll call it then self, and again, I can do g1.I can do g2 equals genome point_mutate.The great thing about unit test so you can say this is the function I really wish I had and then you have to write it, you've set yourself the task.So we're going to point_mutate g1 with a rate of 0.5 and an amount of 0.25.I'm sending it two extra parameters there so the rate is per gene, how likely it is to mutate that gene, and then the amount is, in that gene, how much it will get mutated by.You could put the rate to 100 and it would mutate at least one bit of each gene, for example, and that's how I'm going to do it.Let's implement it.Static method and def point_mutate and it takes g1 and a rate and an amount.What we do is we are going to build a new genome.What we'll do is we'll do g-- Actually, let's mutate it in place for i in range length of g1.Actually, it's easier to go for gene in g1. How about that?For gene in g1, let's call it something better, genes.There we go. I prefer that.Yes, for gene in genes so if np.random.rand is smaller than rate, so if the rate is high, then it's more likely that it will happen.If it's smaller than the rate, we're going to mutate this gene.How do we mutate a gene?We're going to do locus or index is going to be np.random.random integer in the range length of gene, so it's going to mutate one of the numbers in this gene. One of the parameters in this gene is going to get mutated.The mutation value is going to be np.random.rand.Our gene values in the real thing are between in the range zero to one so I'm going to mutate it by that.First of all, I minus 0.5 off of that so that will give me a value, a random number in the range minus 0.5 up to 0.5, and then I'm going to scale it by the amount.I just do gene index equals gene index plus R and that's it.Now, notice that that is actually mutating in place so that's fine.We might deal with that a little bit more later when we get into the full algorithm but for now, that's fine and then I can just print.Print g1 and then let's do print g1 at the end because let's just see if it's changed.It doesn't look like it's changed which is a little bit annoying and I'll tell you why because these are not floating points so I'm adding a floating-point value to integers so it's just rounding it down.Let's try that again.I'll just make these floats.There we go and run it again.There we go.You can see that the original one is there so that's it one, two, three-- oh, the other test is making it a bit confusing.Let me just get rid of the other tests because we don't need those anymore.Let's run it and then, I'll get out of the way, we can see it.Yes, there we go.So there's our original version with all the numbers in and then there's our mutated version.You can see one of them got mutated so each time I run it you should see that one.In that case, two of the genes were mutated.In that case, again, one gene.It's kind of random but the higher the values are,if we set the rate to one, for example, it means every gene will get mutated.Since every gene is mutated now every time.That's just how that works. That's good. That's the point mutation.The final operation I'm going to do is the grow mutation where essentially we generate a random gene and stick it on the end of the genome.This is going to use just some basic NumPy stuff to do that.So test, grow, let's go in here, test, grow.I'm just going to copy this code here.I'm going to call grow_mutate.Now this time, I'm going to say, yes, assert.The length of g2 should be greater than length of g1 because it's going to grow.Basically, I'm going to grow_mutate.There I've got my g1, I'm going to grow_mutate it with a rate of 1, so it's guaranteed to grow.I'll print it out.Then I'll just assert the length of g2.The new grown genome is greater than length of g1.Let's go ahead and implement this code now.I'm going to do def-- No, this is static again.Static method and def, grow_mutate, and I take my genes and a rate.How's it going to work?Basically, if np.random.rand is smaller than rate, then I'm going to do my mutation.I'm going to say new gene equals genome, get random gene, and the length of the gene is going to be the length of gene is naught so that it's the same in case as we change the number of parameters later, it just reads whatever the incoming genes is.That's my random new gene.Now I just need to append it on to the end of the genes.Now, this is a bit tricksy because in NumPy, it's a bit weird.Let's say I've got a genome like this, I've got an array like that, or let's call it g1.If I've got g1 like that, and I do np.append, this is what we might think we could do onto g1, I know I add, I don't know, a load of naughts.Let's say I wanted to do that, which you think if you would just stick it on the end, but what it does, unfortunately, is it flattens it,so you don't want to do that.What you got to do is make into the same shapeas the original array.You put some extra brackets around it, and you put the axis to zero, and then it does what you want.You can see that's doing what I'd expect over there.It's actually dumping it on the end.That's what we need to do.Basically, over here, we're going to do np.append genes, and I'm going to go put gene in an array just like I didin the example there and I set the axis to zero.Then that should do the trick.Finally, I just need to assign that to genes and return genes.Okay, there we go.That's the grow mutation.If you hit play, hopefully, we'll see-- yes, there we go.You can see there's my original genome.Then below that, you can see the original genome plus a random genome has been generated.That should run every time.There we go.There we go. That is the grow mutation.That's the end.In this video, we've been implementing all of the various mutation types that we want to apply and different operations on the genome.We've done crossover, point mutation, and grow and shrink mutation.In this video, we've just completed all of the genomic operations that we need to basically implement the variation in the population."
}