{
  "course": "DSM100-2022-OCT",
  "topic": "Topics 5&6: Creatures",
  "title": "Lecture: Key components in the creatures system",
  "url": "https://learn.london.ac.uk/mod/page/view.php?id=96243&forceview=1",
  "transcript": "[MUSIC]In this video, I'm going to give you a bit of an overviewof the key components that we're going to be having to developin order to implement this creatures system in the next few weeks.Let's have a look at the summary.I'm going to give you an overview of the GA,just as a reminder to contextualize what we're going to be talking about.Then we will discuss phenotypes, simulation, genotypes,fitness functions, population models,computing in parallel,and finally have a quick look at the technology stack as an overview.There's a lot to get through,but don't worry, we're not doing it all in this video.This is just an overview.In the next few weeks,we're going to be building out this system.Let's have a look at that GAand just remind ourselves what we're aiming for here.The GA has these three phases, more or less.We start out with this varied population over there,and then we pass,we go through some selection test in the middle there.We test the various individuals in the population,and then we select them for breeding,and then we end up with, at the end, this one variationsof the most effective individuals.Then we go back again over to number two,which is we test them again.We test, breed, test, breedand keep going until they get fitter and fitter.That's basically what we're going to be doing with this GA.This is a really interesting quote from Harvey's paper.Now, remember, I mentioned Harvey's paperbecause he essentially took the GA and simplified itinto its cleanest possible form.I don't want to do that herejust because in order to do that and understand that properly,you need to have, basically, you need to know how GAs workin their more complicated form before you can simplify them.That's why we haven't done it, the exact Harvey way in this video,but I recommend you go off and read that,but here's his quote aboutwhere the interesting bit is when you're building a GA.\"The most creative and challenging parts of programming a GAare usually the problem specific aspects.\"What he's saying is the bit where you are designingall the interesting stuff about how you're going to simulate it,how you're going to test the fitness, how you're going to encode it,what's your genetic encoding going to be,all that stuff, that's all the creative and challenging stuff.For Harvey, the GA itself is not that complicated an algorithm.It's pretty easy to understand how it works.It gets a bit more complicated when you actually code the thing up.Anyway, moving on.We are looking at the creative and challenging stuff now.The phenotype.We're going to roughly follow Sims with our phenotype,but we're not going to have such a complicated control system.We're not going to have controlling neural networks,but we are going to use the URDF file format.Now, let me just run you something here.This is--Oops, I'm already doing that.This is what this does, is it basically shows youmy simulation running,and you can see it's iterating through several random creatures,so that one's quite good.That seemed to get some good movement on, didn't it?Let's look at another one.I feel like a sports commentator here.Here we have a weird fairly spaced out creature,which doesn't seem to be moving an awful lot.You can see there's definitely some movement going on.Here comes another one.How's this one going to do?This one's got a twisty movement,and you can see it slowly moving, again, not a very successful.These are just random individuals, as you can imagine,and these are what we call phenotypesbecause they're in instantiations of the genotype in the real world.This one, maybe it's going to be moving a little bitbut it seems to be fairly static, not too successful.These are all quite large complicated creatures as well.We'll end up with something like this at the end.We will be able to build this,but I just wanted to give you an insight into that.Let me just kill that now.Those are phenotypes.That's why I'm showing you it.Those are examples of the phenotypes we're going to be working with.You can see there's lots of interesting shapes there,but the problem is, if you just generate random ones,most of them are not very good at moving.That's where the GA comes in.Now, all of those creatures we just sawwere rendered out as a URDF file format.I'm going to show you full details on that.We're going to be programming a system which outputs these files,but we can have a quick look at it now.It comes from the robot operating system technology stack,which is this operating system designed for building and testing robots.It comes with simulation software and stuff like that.PyBullet seems to integrate quite well with it,and have a [?] for URDF files.This is what they look like.Let me get that out the way.They basically have their XML files,and they have a robot tag at the top level,and then they have a series of a link tag.That's not dropped down to the next line,but yes, so each part of the robot is specified in a link tag,which has a geometry.It has one or more parts to the link,in this case a cylinder, and then a collision box.How does this collide with the world,and what was the inertia of this part?You can have really heavy bits of the robot or light bits there.We have loads of links.These are quite complicated robots.Once you get through the links, you then get to joints.The joints actually specify connections between links.You have the parent link and the child link.That's the graph based thing where we're connecting from one node to another.I have a whole bunch of things which specify,like how it connects.Does it connect?You've got two things, right?Then your joint specifies how they're connected and what angle,how far apart they are, things like that.That's what we're specifying here.This is quite complicated URDF file.I didn't write this by hand.This was generated from a genotype and automatically,and that's what we're going to be coding up.That's how we're going to specify our phenotype,so it can be loaded into the simulation.Let's go back to the slides.Next thing is the simulation itself.We actually saw the simulation running just then, didn't we?We saw a phenotype being expressed and run in simulation.As I said, we don't have a CM-5 handy.We don't have one of those amazing,most powerful computer in the world from 1993 with nice red lights.We don't have one handy,so we're going to have to run it on our own machines,but that's okay because at the time of filming, it's 2021.We've got pretty fast machines lying about the place,which we can useand we're going to use the PyBullet physics engine to run our simulation.The creatures are going to be interacting with the physics engine through thatbecause we don't have to build our own physics engine at this point.What about the genotype?Well, the genotype, we're going to follow SIM,so we're going to represent,we're going to have a genotype which is manipulable,but which can represent some directed graph.There's going to be some simplifications around the control systemjust to make it easier to code up in the time we have.Then what about the fitness function,which is basically going to be, how far does it move?That's the short answer for what the fitness function does.That should be fairly easy.We're just going to measure where it starts,and then run it for a few cycles and see how far it's got.That's going to be the fitness function.You could see when we were watching the animations earlier,that that should be fairly easy to implement.Now, the end problem is they're going to cheat.When I was developing this, so before making the videos,I built out the whole thing and planned itand made sure it is working more or less how it should.In that process, I found that the big problemand the very often reported and entertaining problemwith evolutionary algorithms is whatever simulation you create,they will find the problems with it and exploit it.They'll figure out a way of basically, I don't know,finding some free energy somewhere by wiggling in a funny way,or they'll figure out how to fly when they're not supposed to be able to fly.I'm going to show you exactly that now.I've got an example ready of one of the cheating ones,and that is over here. Let me run the cheater.You can see, so I call this one helicopterbecause it basically spins like it.I figured out, oh, look, see,I guess it's more like a fly or something, isn't it?One version of it actually span around.You can see that it's whizzing,flipping around, spinning aroundand getting higher and higher away from the ground there.Yes, they are going to cheat, and that is an example of it.I was exploiting the fact that the joints between,I couldn't fully work it out,but I think the joints between the parts of the robot are stiff,have a certain springiness in the simulation.I think what's happening is it's worked outthat if it moves in a certain way,it can generate a load of energy from the spring.That allows it to move through the airwithout actually gravity being able to pull it back down again.We'll have to work out ways of stopping the things from cheating.Within our testing environment, our fitness function environment,we'll have to figure out a way to block that bad behavior that we don't want,because the evolutionary algorithm will try and cheat,but we can then put an extra layer of testing into make sure that if it does certain things we don't want,we can stop it, but we'll get into that later.That's the interesting bit of the fitness function,stopping it from cheating.Then in terms of the population model,we're going to implement the roulette wheel selectionthat I talked about in an earlier video.The next thing, we're going to be doing computational parallelism,because we're going to get Hollands implicit parallelism for freebecause it's a genetic algorithm.It comes with that.We want to also do computational parallelismwhere we actually are able to run multiple simulations on different cores,because even a simple laptop like the one here, I think has six cores.I can, in theory, run six instances of the simulation in parallel,which means I'm going to get six times to speed up pretty much straight awaybecause I can evaluate six individuals at the same time.Yes, we're going to use that.We don't have 1024 cores like Carl Sims hason his amazing CM-5, but that's okay.CPUs that we do have are a lot faster than the sparks that he had.Okay, moving on.What about the technology stack?Well, basically, it's going to be Python, we're going to be writing in Python.It's going to be using the PyBullet physics engine,which is, as I say, used by a lot of robotics researchers.We're going to be using the URDF file format,which is also used by robotics researchers.We're using some of the--I've deliberately chosen this technology,firstly, because it gives me the appropriate functionalitywithout having to build it all myself from scratch,but also, because it's an opportunity for you to learn these environments,which are used for this research.You'll find that when you dig around in the PyBullet manual,the documentation,that lots of people are using this stufffor doing interesting stuff with machine learning, and robotics, and so on.It's good stuff to learn.Okay, the end.In summary, we've just been having a quick overviewof what we're going to be implementing in the next few weeks,and seeing some examples of how things are going to workand how things that might go wrong.Yes, I've talked about the phenotype, the simulation, the genotype,the fitness function, the population model,how we're going to be doing this as a parallel computing system.We're going to use the parallelization features of Python.Finally, I had a quick look at the technology stack at the end there.In this video, we've just been having a quick overviewof the system we're going to be building in the next few weeks."
}