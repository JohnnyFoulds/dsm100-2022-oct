{
  "course": "DSM100-2022-OCT",
  "topic": "Topics 5&6: Creatures",
  "title": "Lecture: Evolution!",
  "url": "https://learn.london.ac.uk/mod/page/view.php?id=96330&forceview=1",
  "transcript": "[music]In this video, we're going to be pulling all of the code together that we've been working on in the last many videos, which constitutes the genetic algorithm.In summary, we're going to implement the genetic algorithm, and then we're going to run it and we're going to make some tweaks as we go.Here is the genetic algorithm in pseudo-code form.We're going to generate a random population, we're going to evaluate it, we're going to get the fitness and the fitness maps, we're going to make a new generationby iterating over each creature that we want in the new generationand selecting parents, making new DNA through crossover, mutating the DNA, and then making a new creature with that mutated crossedover DNA.Then we go back, we iterate back to the evaluate step.We're going to do it all as a simple test. Let's do it here.I could write thisin a nice genetic algorithm class or something like that, but for now, I just want to see the raw code sitting there and quick to run so we can work through it and test it as we go.Let's save this new file as TestGA.The first thing I'm going to do is I want to import unittest, and then I'm going to write my class TestGA, which is going to extend on unittest.TestCase.Then I'm just going to define a testGA function and I'm going to write the unittest.main.What's first?First off generate a random population.That's easy to do because you've got our population class.Let's import that as poplib.I'm importing it and calling it poplib.Pop = poplib.Population.It takes two arguments.It takes the population size and the gene count.The population size is 10 and the gene count could be anything, but I'm going to do 10 for now.Gene count is three.That's my random population.Next up I need to be able to evaluate the population.To evaluate a population, I can use my simulation class.Let's pull that in. Import simulation as simlib.Now simlib, so let's create a simulation = simlib.-- and I'm going to create a threaded simulation.Threaded simulation takes one argument which is the pool size, which is the number of threads.Pool size, and let's set that to eight so that we can use as many of the threads as we can on this machine.Great. What's next? How do I evaluate population?I do sim.evaluate and I pass it.The population and the number of iterations.Now, the number of iterations maybe is a little bit of an obscure.What does that mean? Iterations, so let's go in and just put a comment in to remind ourselves what that is.Pop is a population object and iterations is frames in pybullet to run for at 240 frames per second.That's just a comment.You'll see now if I mouse over it, you can see my comment appears instead of that generic stuff.That's clearer. Let's run it for 10 seconds.Good. What's next?Get the fitness and the fitness map data structures.Fitness = and now evaluated the population.I can just do, let's just import the creature first because we might need that in a minute creature as crlib, cr.get_distance_traveled for cr in pop.creatures.With that code there, I'm iterating over all the creatures in the population asking each of them how far it's traveled, and then I'm storing the results back into an array with a list comprehension great.The fitness map is, I can get that by doing poplib.Population.get_fitness_map and I pass it the fitnesses.Just to verify.That takes an argument fitness.I've got my fitness map.What's next?I need to make a new generation or make a new generation.New_gen is going to be an empty list to start off with and I've got to fill it up with creatures.For creature index in range,and the range is going to be length of pop.creaturesbecause I want to have one new creature for every oneso the population mains the same size as we iterate.I don't want it to grow and become a bigger population.What do I need to do to create a new creature?I, first of all, select the parents.Parent 1_index = poplib.Population.select_parent, and I pass it the fit map data.Okay, fine.Then parent 2 index is also pulled from that, so that pulls out two random parents.Well, not random.Weighted random from a weighted distribution, which is your roulette wheel selection.Then the next step is, make new DNA via crossover being careful, it says careful in brackets up there.How am I going to be careful?Let's just see how we go.I'm going to do DNA = pop-- Ooh, how do I get the cloud to do crossover?It's genome lib so I haven't got that yet, have I?I need to import genome as genlib.That's the genome that gives me access to crossover and mutation functionality, genlib.Genome.crossover.I'm going to cross over on the-- What does crossover take?It takes G1 and G2, whatever they are, let's make that clearer.G1 and G2 are raw DNA data lists of lists of floats.There you go. That's made that clearer.If I mouse over it now it should tell me that comment lists and lists of floats.How do I get the raw DNA data?That would be pop.creatures_parent1 index.dna.That's the first one.The second one is going to be P2 index.Let's put that down there, tab it in.Okay, P2 index DNA.I'm passing the raw DNA of the two parents I've chosen into this function so that I can now generate the new DNA.At this point, I'm going to go and be careful as it instructed me to, and I'm going to check out this crossover function.I didn't do many tests on this because I just wanted to write it quickly.It's possible that we can end up with some bad values for crossover here and the numpies catenate function might complain.What we're going to do is if XO comes out as zero, just return the whole of G2 actually, because we are crossing over at 0.0.That means we're having none of G1, we have all of G2.If XO is equivalent to length of G1 - 1, then that would mean we want all of G1.Return in theory, G1.That's just making that a little bit it more robust so carry on.Then I can hit play at this point just to verify I haven't done anything silly yet, so let's just run it.That worked and it didn't crash.I've got some output coming out here that I'm going to get rid of because I don't want to see all that.I'm going to go into-- I think that's coming out of the simulation somewhere.Let's go into the simulation and find the print.Yes, there we go.I just did a search for print and there it was.Let's just come that one out, print that, and then I think there's another print somewhere else.Yes, there we go.Comment that out as well. That's got rid of the prints.Let's run it again and just check that it's nice and clean now.Nothing coming out there so that's good.Next step, where am I?I'm on the mutate step. That one.It says mutate checking for crashes on mutate functions.Let's mutate the DNA now.We've crossed it over now. Let's mutate it.DNA = genlib.Genome.point_mutate.Let's do a point mutate first and point mutate-- Shouldn't be some square brackets there.Point mutate takes as its arguments the genes, the rate, and the amount.The genes are the DNA.The rate is the chance of a point mutation per number on the genes and then we pass the amount, which is how much it's going to get mutated by the maximum amount that it can be mutated by.There's another problem with point mutate, which is that it's inconsistent with the other mutate functions and the crossover function.Crossover, you can see actually returns the result of the crossover, which is great.Point mutate doesn't return anything,whereas the other mutation functions do they return the mutated gene.Let's just make it consistent, make it return as well.It's going to return the genes.That's now consistent.Let's go ahead and do the other mutations.We got the shrink and the grow mutate.Let's grow it first and then shrink it.It could be that we end up deleting the one that we just added, but that's okay.This one only takes one parameter, whereas it takes the DNA of course, but it also takes the rate, which is basically the chance of it deleting one.In that case, that's the chance of it growing, so a 25% chance of growing and then 25% of shrinking.That's good.What we want to probably do is check, shrink is robust as well because shrink is very basic at the moment doesn't do any checking.What I'm going to do is if length of genes is one just return genes, because I can't shrink-- If it's only got one gene, I can't shrink it because it will have no genes at all, it will be useless.Great.Where are we up to?We've mutated, we've checked for crashes on mutate functions and put the fixes in there and then we've got to make a new creature with this DNA.It gets tricky again here.The problem is that, as far as I know, you can't overload a constructor in Python.You can do some nasty stuff, like put some flags in there, which make it behave in different ways, but that's what we call module control coupling, which is generally considered not a good technique.What I'm going to do instead is basically construct a basic creature, and then I'm going to have a function to replace its DNA.What I'm going to do is say creature = crlib.Creature which I imported earlier and I'm just going to give it one gene, so it's just going to be emptyish.Then I'm going to do CR-- Now I need to add this set DNA function on the creature, which will cause it to update its DNA.I'll put it here.So, def set_dna(self, dna).What's it going to do, it's basically going to say self.dna = dna, and then it's going to do all this stuff.You notice the constructor, instead of receiving some DNA, it generates some random DNA.but then it does a bunch of stuff to set itself up, so it's ready to generate the XML, doesn't it?I need to make sure it does that here as well, because once I've updated the DNA, it needs to regenerate all the links and joints and stuff and motors.That's what it's doing there and resets its position and everything else.Great. That should be good to go.Now I have programmed the set DNA's function.I'm going to call it on the creature and I'm going to pass the mutant crossed over DNA, and then I need to just add the new creature to this new gen list.I just do that.That is more or less it for my one iteration GA.I can run that now and see if it's going to cause any problems.That's running well.Next, I need to actually iterate on it right.Of course, we've just evaluated one generation there, so we need to iterate on it now.What we're going to do is, so those are the bits where I create stuff, that all the rest of it is going to tap in and be put inside for loop.I'm going to say, for generation in range 10, let's just do 10 generations for now.It's just going to run that code again and again.At the end of this bit here, I need to then say pop.creatures = new_gen.Essentially, I'm just replacing all of the creatures from the previous generation with the new ones, and you could do something more complicated, like storing them or something, but I'm just doing the basics here.That's iterating.I just want to print out some stats just to show what's going on.I'm going to import numpy as np, and after I've evaluated the population, I want to print out some stats, I'll print the generation and I'll do the highest one, and I'll do the mean.That's just showing what the best one that we've achieved is and what the mean is.We're ready for a little drum roll now because we're going to run the iterated genetic algorithm for the first time and here we go.Let's press play.There it goes.It's kind of jumping around a bit and it's not necessarily increasing the fitness very well, but then we haven't really completed the implementation totally yet.Let's just do another run just out of interest, one more run.[silence]That's more or less it, that's what we're going to do.We've now got the genetic algorithm implemented, and it's running and we are generating different general population each time.The fitness is jumping around, it's not necessarily increasing, but we're going to work on that in the next video when we do a few tweaks.In this video, we've been pulling all the bits together of the genetic algorithm and kind of putting it into an iterated proper algorithm which is able to evolve a population of creatures."
}