{
  "course": "DSM100-2022-OCT",
  "topic": "Topics 5&6: Creatures",
  "title": "Lecture: Artificial evolution and genetic algorithms: fitness functions, genetic encoding and manipulation, population models",
  "url": "https://learn.london.ac.uk/mod/page/view.php?id=96231&forceview=1",
  "transcript": "[MUSIC][MUSIC]-In this video, I'm going to explain how genetic algorithms work.In summary, I'm going to start out by just explaining,giving you a brief definition of genetic algorithms.Then we're going to talk about encoding with a genotype,decoding and testing with a phenotype.Then we'll talk about selection and breeding and mutation and go back tothe start again to show that it's an iterated process.Let's start out by looking at some definitions.The question is who invented genetic algorithms?John Holland, from the University of Michigan, is credited with a lot ofthe early work in the '60s and '70s on genetic algorithms.Obviously, many other researchers contributed as well.Since then, many more have come in and added all kinds of things to it.John Holland's 1975 book Adaptation in Natural and Artificial Systemsis considered to be the seminal textbook if you like,earliest textbook in this area.What about a definition of genetic algorithms?It's a probabilistic search procedure designed to work on large spacesinvolving states that can be represented as strings.Who said that?It is Goldberg and Holland.Holland, we just mentioned.Goldberg's another key researcher in the field.Let's pick that apart a bit.It's a probabilistic search procedure.Probabilistic search procedure.That means that it's essentially--a genetic algorithm is a search algorithm.That's one thing to know.The question is, what's it searching for?Well, it's searching through a large space and the space contains states.In that space, there are a whole bunch of different states, and thosestates are described or represented using strings.That's the abstract description of what a genetic algorithm isand what it does.Now, the question is, how does that relate to evolution theory,if you like, why is it called a genetic algorithm?Well, we've got selection going on up there.The probabilistic search is this process of selection and breeding.Then down there, we've got the representation,which is the genotype.The string representation is the genotype.Over there, way over there, we've got the phenotype,which is the states if you like.Typically, in a genetic algorithm, it's simplified a bit.It's simplified into-- the state is directly derivedfrom the string, the genotype.The phenotype is directly derived from the genotype, typically.Unlike natural evolution, where the genotype gets expressed,and then evaluated in natural world.It's a simplification of natural evolution and abstraction of itto extract the useful behaviors and characteristics of natural evolution.What's the point of all this?That's all very abstract.What's the point of it all?We define the space.The space that we're searching throughis the space of possible solutions to a problem.A genetic algorithm is a search algorithm that's searching forsolutions to a problem, which is normally what a search algorithmshould be doing.When you do your search on your search engine you're--The problem is, I don't know which websiteto look at for this particular thing.It searches and it sends you back, \"Here's a set of possible websites.\"Similarly, instead of it being a search for websites, we're searchingfor solutions to problems.The space or the states are the solutions andthe strings are how we describe those solutions.Typical examples of problems are listed below.You can see we have, for example,what's the ideal shape for an aeroplane wing?That's the example we're going to be using in this video.Another one might be what are the ideal settings for my data centerto reduce power consumption?Then the final one is the final example, what's the most efficientrobot form for walking?Shocker, that's what we're going to be doing.In later videos, we're going to be actually building a genetic algorithmwhich allows us to evolve robots which can move, basically.Our space of possible problem is, we don't know how to design a robotthat can move, and so the space of possible solutions will bea whole bunch of different shapes and configurations,which allow us to find one.Moving on.What I want to do now is jump over to my editor program over here.What we're going to do now is we're going to look at how we can possiblyencode a problem as a string and then we're going to work through and seehow we can then manipulate that stringto implement the genetic algorithm.Let's first off, think about a problem.I'm going to take the aeroplane wing problem.Imagine I need to know what is the best aeroplane wing design?I've got a range of different designs.I've got a flat wing.I've got a triangular one.Maybe I've got a curvy one like that.I could even have something that looks more like that.I've got four different shapes of wing.The question is, how might I describethose using some string representation?Remember, the string can have anything.Any characters in, whatever you want.Commonly in genetic algorithms, the stringis actually a binary string, zeros, and ones.I want you to pause the video and have a think about howyou would describe these various wing shapesusing a standardized string description.Maybe pause the video and have a think about it.I'm back again, if you paused it.What we're going to do is now come up with a solution to this.The first thing is, I noticed that there's four distinct shapes here.Maybe I can start out by saying,\"I need some bits to describe which shape it is.If there's four, I can use two bits to describe that.\"I could say, maybe this one's going to be represented by two zeros.This one's going to be a zero and a one.That's going to be a one and a zero.That's going to be a one and a one, so with two bits, I've now describedeach of the possible shapes.The first two bits of my representationare, in fact, going to be the shape of the wing there.Next up, I might say, \"Well, what othercharacteristics does this wing have?\"Well, I could say, \"It's got a length like that.\"Each of them has a distinct length.That might be the next two bits or three bits.Maybe I could be generous and say, \"I can have eight different lengths.\"I'm going to have three bits for that so that's my shape.Then I have another bit, which isanother three bits for the length maybe.I can have eight different lengths.Then the next thing is, I might say,\"It's got this idea of being bent around.\"It's got this kind of angle concept.I might say, \"Let's have a look at the angle.\" That one has got thisangle like that.Then this one has that angle.This one's got that angle, and so on.I define an angle for each one if it's bent or not.That allows-- I could do that with another.Maybe I can be generous with the angleand maybe have four bits or whatever.It's up to you to describe how preciselyeach of these things is represented.Now, I've actually represented a wing as a bit string.That's great.I've now got my-- The space of all possible bit strings.Think about that, it's 2^9.What's that?512?I've got 512 possible wings that I could have with that bit string.That's pretty good.That's a good starting point for my genetic algorithm.Generally, you'd have a longer bitstring to give you a really large space.Remember that definition, where it said a large space 512points is not really a large space, is it?Imagine a much bigger space.Anyway, that's just a simple example.I've got my genotype.That's my genotype.The next step is to express that genotype into a phenotype, whichremember, is the physical expression of this.We know how we're going to do that.We're basically going to chunk through those bits and interpret itinto our wing and say, \"Well, okay, that's going to be a wing.\"The question is, how do I then?Now, I've got that description of a wing,how do I then test that and see how good it is?That's the next step.I'm just going to pause again.I want you to have a quick think, how am I going to test this wing?How would you test these different wings in a computer?I'm going to show you how I'd think about doing it.I might say, \"I'm going to build myself a really basic physicssimulation, where I basically get my two-dimensional wing shape.\"It's going to be 2D physics,really easy, and I'm going to blow some wind at itI'm going to create some forces.I'm going to blow those at the wing.I'm going to simply measure what the force is going up.If you like, the uplift.What's the lift generated by that wing?My fitness, if you like, the result ofmy evaluation is how big that is there.How much does it raise up?We literally have a physics simulation.I'd instantiate each wing into a little object in the physics worldand I would run it with some wind, andI would measure how far it goes up.That would give me a fitness score foreach of the wings in my initial population.It's worth saying that you need a starter population.I'll start out with a population of a whole bunch of variants of the wings.Maybe one will be like that, maybe like that, and maybe a triangle,maybe a bent triangle, and so on.Maybe I'd start with, say 10, but typically in a realgenetic algorithm, you'd have thousandsin your initial population, possibly.It depends how computationally expensive your physicssimulation is, and so on.There's various things.Yes, it's fine to say, we've got a population of different things,we're going to test them all, and say,\"Okay, what's the lift on each of themwhen we blow wind at it?\"Then that gives us a score for everything in the population.That's the first part of the testing and the breeding.The next step is, I need to say,\"Okay, I need to generate the next generation,\"because it's all very well to have scored maybe 10 solutions.I could just stop here and say,\"Well, I'll just get the best one out of the 10.\"If you've randomly generated them, you can't guaranteeyou're going to have a good solution soyou need to be able to iterate on these.That's the whole point of the genetic algorithm, you're searching,you don't just do a one-step search and that's your solution.Actually, it's an iterative search through this space.That's what we need to do.How do we iterate?Well, so the next step is to select two of the individuals for breeding.Okay, how does breeding work?How does selection work?Well, let's do selection first.Selection works like this.It's called roulette wheel selection.I'll draw a wheel or a wheel of fortune selection but yes, typicallyin the literature, it's called roulette wheel selection.Let's say I've got a population offour to make it simple for me to draw.Okay, so I've got four, that would give me four segments.One, two, three, four.I've got four segments, and the angle of the segment,that angle, or that angle, rather,that angle is basically the fitness.It really fits wings, so maybe the triangle wing does really well in thesimulation, maybe a weird stubby wing like that doesn't do so well.Maybe the banana wing is the worst one.Maybe a really thin triangle.Say I had four individuals, I'd measure the fitness of each,and the higher the fitness, the greaterthe angle it gets on the wheel of fortune, the roulette wheel.The next step is, so if you've ever watched a James Bond film,or whatever, or been to a casino, et cetera, you spin it around,so you spin around the roulette wheel,and wherever it stops, that's the first parent.Then you spin it around again and that'll give you the second parent.Now, you can imagine that the more of this you have, the higherthe chance of you being selected when you spin around.That means that the fittest individualsare more likely to get selected.It also means that the less fit ones have a possibility of being selectedas well so they don't get completely discarded,just in case they've got some useful stuff in there.I'd end up with two individuals.You can see I've selected the triangle one,and the stubby square wing.Though that's my selection process, and I would do that multiple times,to get multiple pairs of parents.The next step is I need to take those two parents, and I need to recombinethem in some way to generate the next generation.The first individual that's going intothe next generation is going to be some combination of those two.How am I going to do it?Well, there's two steps, there's crossover and then there's mutation.Let's look at those two and see how they work.This is crossover.Imagine I've got my two genomes or genotypes, like this.That would be the triangle, and that would be the other one I selected.Those are the two parents I've selected.Crossover essentially is looking at taking part of oneand then part of the other.One point crossover would be-- I'm going to take the top, maybe that bitof that genome and that bit of that genomeand that would give me the next generation.You can also do a multipoint crossover.You can say, \"Well, I'm going to get that bit and that bit,\"or with really long genomes, maybe youcan end up with different whatever you wantAll kinds of combinations, but the basic one is say, we'll call itsingle-point crossover like that.You would typically use a random number to get to choose where youcrossover or maybe you'd look at the fitness and say, \"Well, again, I'mgoing to apply the fitness again and allow it to choose so the fitterindividual, I'll take more of its genome.\"Again, you've already applied theselection pressure, so why reapply it?I think in the previous video, I've givenyou a link to this Inman Harvey paperwhere he goes through and really picks apart the geneticalgorithm says, \"Well, why would you apply selection pressure twice?You've got selection pressures, just applyit once and simplify your algorithm.\"Let's just say it's a random number.What's the result of that?Well, if I just change the color for the bottom one, I'll end up with thatof that one, and that of that one, and that's my new genotype.That is my new genotype, it's got abit of one parent, a bit of the other.If I was to express that into a phenotype, maybe I'd end up with,I don't know a slightly, slightly blockier triangle, I don't know,whatever it is.The bottom one is a combination of the other two.That's how I do selection and breeding.Remember, we need to do mutation now.The final step is to take this child and then we mutate it slightly.Again, randomly, we would choose places on the genome to mutate it.If we just redraw it and put in those mutations,what I'm going to do isI'm going to pick some random points on it, I'll say, well, that bit therethat bit is going to flip, that bit's going to flip.Depending on, you have some percentage of them that get mutated.You could basically flip the bits on those,and then you end up with a slight variation.You've got a combination of the two parents with a bit of change,to give you a nice amount of variation.Remember, we do this multiple times, we go back, we do the roulette wheel,we spin it around until we get lots of pairsof parents, and we do the crossover mutation.Eventually, we end up with, say 10, or whatever our population size is,we end up with a whole bunch of new genomes in our population.Then, of course, we go back to the startagain, we go right back to this stepWe evaluate the whole population againand then we do the selection.We do the crossover and mutation and we keep going, and we go around andaround until eventually, we end up witha population of really good solutions.As I'll show you in a later video, so John Holland'sschema theorem describes why this works.It explains why doing this weird looking process,why it allows you to search highly complicatedspaces, and find decent solutions in thosespaces that other types of algorithms might not be able to find.For example, hill climbing, where you just always choose the next,you mutate and find the best next one,you don't have a population doing crossover and all of thatWe put all these features into the genetic algorithm.Holland describes why they work using his schema theorem,which we'll talk a bit about in a later video.Okay, I think that's it.Let's just summarize.We've just been talking about the genetic algorithm.I've told you who's credited with the mainseminal work on this, which is Holland.Then we've talked about encoding.How we take a problem and express it in the formof a string of bits in our case, or numbers.Then we talked about how we express that and test it, how we convertthe string of bits, and run it and test it,and that gives us scores for various strings.Then I talked about how we select and breed those strings to producethe next generation and how that continues iteratively until we havea whole population that's fit.Okay, in this video, we've just seen a worked exampleof how genetic algorithms work."
}