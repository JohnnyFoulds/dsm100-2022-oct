{
  "course": "DSM100-2022-OCT",
  "topic": "Topics 5&6: Creatures",
  "title": "Lecture: Implement the fitness function",
  "url": "https://learn.london.ac.uk/mod/page/view.php?id=96317&forceview=1",
  "transcript": "[music]In this video, we're going to implement the fitness function.In summary, we're going to start out by thinkingabout what the fitness function is going to be, in other words,what we're going to measure.What we're going to do is actually measure the distance traveled by the creature.Then we're going to look at how we can evaluate a whole population,and we're going to encounter some other considerationsand problems along the way.First of all, why measuring the distance traveled?In the original Sims' paper, that's exactly what he does.In later papers, he does measure how much time the creatureshave been able to hold possession of a particular object,and they also following lights, and things like that.I'll certainly leave that for you for future work.Here, we're just going to do the classic thing of measuringhow far the creature moves in the simulation time.We can compute the distance moved using this bit of numpy code.I'm going to add that into the creature class right now.I'm inside the creature file here, creature.py.I'm going to add a new function called \"get distance traveled\".Because it's going to use the state of the creature, it receives self.What I want to do is, first of all, I need to convert the two vectorswhich represent the start position and the end position of the creature,or the last measured position of the creature,I need to convert those into numpy arrays.I'm going to just say position one equalsnp.array of self.start_position,and position two equals np.array of self.last_position.Those are converted.Now, I just need to do distanceequals np.linear_algebra.That stands for, linalg.norm.I'll just do p1 - p2.Then I can return the distance. That's it.That should allow me to ask the creature how far it's traveled.Now, there's one other thing with the creature,which is if we call this function before it's had its position set,then we're going to have a problem.What we need to do is just we can sayif self.start_position is none,or self.last_position is none,actually is not equals, return zero.We just say distance traveled is zero if you're not ready to go yet.That's great. That's done.I can just go back over to my slides now.The next step is to use this in our test script.Remember we had this test motor script which essentially generatesa random creature, sticks it on the screen,and moves its motors.Let's just see that script again, and then we can add this code to that.This is the script, which basically does it.Then if we run it, we should see a random creature springinginto the air, and then attempting to move along by moving its motors.What we're going to do is we want to add some functionality to this scriptso that it brings out the distance that the creature has traveled as we go.What I want to do, I need to initialize the creature's position.I'm just going to say initialize it to the zero position.Should be creature.update_position.I'm just going to send the origin.I'll assume that it starts at the origin, and measure the distanceit's traveled from there.What I can then do is I can do c.update_position.Now I'm going to update the position according to where it is.In order to get the position of the creature at the moment,I can do pos, orientation equalsp.getBasePositionAndOrientationfor this creature.That's an API function from the PyBullet library,getBasePositionAndOrientation, which will return a posand an orientation.The orientation's what's the angle of the creature, and then the positionis where is it in xyz space.I can then update the creature's position using the position partthat return like this.Finally, I can actually now print out the distance traveled.I can do print(c.get_distance_traveled).As the simulation's running, it should be printing out the distanceit's traveled, or at least not necessarilythe distance traveled, but the distance from the origin,from the original point at the current time.Let's run that. I'll pop that over there.Hopefully we'll see the numbers scrolling up over there.You can see I've got this slightly interesting-lookingwormy type creature, and it's not really getting anywhere.It's sticking at around 1.9, whatever the measurement is there, units.That's cool. That seems to be working.It's got a bit farther now.We can run it one more time just to see if we get somethingthat moves a bit more dynamically.Notice that as it's flying into the air, because remember it has to be rejectedfrom the plane that it sits on, and then it falls down,so you saw the distance went up, and then it went back down again,and then it started moving.That seems to be working.The next step is to actually do it in the simulation.That's the test script, how do we add it to the simulation?You may have spotted on the slide there that it says whoops, no floor.Let's see what that does for us.We'll encounter that problem as we go.What I want to do is I'm going to go into the simulation code here.The part of the simulation where I'm actually just movingthe creature and moving the motors, I've actually got the update positionsbeing called already for me.What I'm going to do just to test it, I can actually go and do this properlyand write a script.I can say let's go test,let's do a quick test for test distance moved.I'll call it testDist(self).I'm going to basically copy this.I'm going to just run a random creature in simulation like this.At the end, I'm just going to measure how far it's moved.I'm going to do self.assert, sorry, going to get my auto-completion,assertGreater.I want the distance moved to be greater than zero, basically.I'm going to do cr.get_distance_traveled.The test is going to assert that the creature has moved,distance traveled is greater than zero. Let's run that one.That all looks good.It looks like it passed that test, good, confirming that the creatureis indeed traveling in a simulation.I want to dig a bit deeper and see what's going on here.If I just do a printout here to saycr.get_distance_traveled,we can see what's going on.Let's run that test script again.That's just in the simulation run creature function.I'm just going to print out how far it's traveled to see what we get.You saw there, see how far it's traveled.It's way higher than those simple creatureswe saw in the other script. That makes me suspicious.When I see that 136 like, \"How did it get to travel 136?\"Either it's an amazing creature, by chance, I've ended upwith this really amazing creature that can just run niftylyacross the screen, or something going wrong.Chances are something is going wrong, because that's what normallyis the case when you're writing code.Let's see if we can evaluate that a bit.What I can do is I can say print(pos[2]), so print(pos[2]).Pos[2] is the y position of the creature, because my suspicionis that something interesting is going on.You can see my y position, which is the first value,coming out there, seems to be negative.What do you think it means to have a negative y position?Yes, \"oops no floor\".[chuckles] That's what it said on the slide, remember.It means the creature is basically being dropped,and then it just falls through the floor because there is no floor,and it just keeps going down.That's why we're getting these fantastic distances.The solution is to put a floor in.Let's check our code and see what's going on.The relevant bit of the code is up here.At the top of the run_creature function, we are configuring it alland everything else, but we're not adding a floor,because when we do reset simulation, that will remove everythingfrom the simulation, and there's no floor.We never added a floor anyway.We can go back over to our motor test scriptand steal the code from there, which creates the floor,which is these two lines.We'll look at those in a sec, what they're doing.Essentially, it creates a, what's that, collision shape.It creates a shape.Then it uses that shape to create something in the worldusing that as the collision shape, and as the visual shape as well.Yes, we just need to do that.The only thing we need to add is the physics client ID,because, remember, we're creating the floor in our own physics engine.If we don't put an ID in, it'll default to zero.I'll only ever create it in the first physics enginethat we create. I've created a floor.If we now run the test again, it should hit the floor,and then we should get a much more reasonable distancecoming out there. That's looking good.You can see that the-- I'm not sure which one's which,but I think the y one's probably the higher one, which is going down.It's gradually-- I guess it's going to fall down eventually.Have you gone down? Yes, it looks sensible now.It looks more reasonable.I'm happy with that, that it's now got a floor.If I just remove that printout, because that's a little bit verbose,I can run it again and just verify I'm getting a sensible distance there.Good. That's all working, brilliant.Now, the next step is, now I'll fix that, to see if we can goabout evaluating a whole population.Let's see what we can do there.This is pretty easy actually, all we need to do is create a population,and just run each of the creatures in turn through the simulation.I can do that right here in my test simulation script.I'm going to test pop.I'm going to create a population.Pop equals population.-- I haven't imported population yet,let's do that. Import population.Let's try again. Pop.population.Pop size, I'm going to have 10 of them.Then gene count, say three.I'm going to have 10 individuals each with three genes. That's that.Then I need to just create a simulation like this.Then next, what I'm going to do is iterate over the creaturesin the population, and evaluate each of them in turn.I can do for cr in pop.creatures.I can just run them in simulation, like that.That's good. I'm iterating-- Oh, sorry, that shouldn't be tapped in.I'm iterating over them.At the end, what I can do is I can just collateall of the distances traveled and print them out, how about that?We can say dists equalcr.get_distance_traveledfor cr in pop.creatures.It's going to iterate over all the creaturesusing a list comprehension, and ask each one how far it's traveled,and store that into dists.I can just do self.assertIsNotNone on the dists.For now that would be fine.It allows me to run the code without having to dotoo much evaluation there.Let's run that one and hopefully-- That worked.Sometimes we hit this error.I discovered this when I was developing the code.The error is-- I should get out of the way so you can see it.The error is that something's going wrong when I'm accessing the motorson the creature, because the list index out of bounds.Luckily you don't have to spend the time I spend debugging this,because I'm going to tell you what's wrong.The problem is there's one other little linein the test motor script which we haven't gotin our simulation initialization, and it's this line here.Remember the file caching that I talked about earlier.If you've got the same file name and you try and load it twiceinto the same simulation, it will cache that file,it won't update it.What we're doing, remember, is we are rendering out 10 files to disk,one in turn, all with the same file name, and then attempted to load them in turn.The problem is it's just caching them.I just need to add this line to our simulation code as wellto make sure it's being configured correctly.We'll do that here after resetting.Remember, I need to pass in the physics client ID as well.Then that should be hunky-dory, as they say.Let's run the test.Another interesting thing is it only appearedthe second time I ran it, because it's random,it's not going to happen every time.Let's run it.That's cool, but I want to just make sure it's not going to happen,so I'm going to just make a big old 100 populationthat I'm bound to see the error in a 100 of them.It's evaluating 100 creatures now for 10 seconds each.It's definitely thinking about that one a bit more.It's not crashing, and that's the important thing.I think I'm more or less there.Great, nothing went wrong.I could even print out the dists if I trim that back down to, say, five.I can just print out the dists just to see what kind of spread of distances I've got.Let's just do that.There we go. These are the distances traveled.You can see that one.I'm not sure which one it is because there's two printouts.Probably this one with a variety of different distances there,and so you can see. Yes, it's definitely that one.It's got the two, three, four.We've got a nice variety of different distances already,which is what we want for our evolution process. That's great.That's pretty much it. That is our fitness function.Whoops file caching, yes.There's one other thing I wanted to deal with here,right at the end, which is the flying into the air problem.If I run that test motor script again, you can see--Let's run it from here actually, I'll get out the way.If you run this again, one thing I noticed,you see how it flew up in the air?Yes, that's a bit of a problem, isn't it? Why is it a problem?Because depending on the shape of the creature,when it flies up in the air, depending on the shape of the creature,it'll fly up more or less, it'll get further or closer to the origin.If we're measuring the distance from the starting point,then it's a bit of a problem because it might gain an advantageby having a weird shape, and getting some big boostat the beginning when it's actual walking might be rubbish,but it ends up really far away because of its shape.We don't want it to be allowed to do that.What we're going to do instead is we're going to just drop it.Instead of letting it fly into the air, we're going to drop itjust above the surface, and it'll fall downand then start walking.How are we going to do that?What we do is in the simulation-- Let's try it in the test script first.Up here we can just doto p.resetBasePositionAndOrientation.That allows me to specify a hard coder positionand an orientation for the robot.The orientation's going to be just that, which is straight up, basically simple.Then the position is going to be zero.X and Z are the first two, then Y is the second one.Let's put it up at minus five to see where that puts it.If we run that one, you'll see that it crashes, whoops,because I forgot to pass it the idea of the creature.Let's try that again.There we go.That didn't quite work.Let's try that again.Reset base position and orientation.Zero, zero-- Oh, because I've put it minus five.Whoops, I put it below the floor, and then it got there. That's bad.Let's put it above the floor, let's try that.Yes, there we go.Now it's sinking down nicely and landing on the floor.Then it can start moving from there. That's quite a good one, isn't it?We just need to call this line in the simulation.Maybe five is a bit too high, let's put it at 2.5, one last test.There we go. That's good. I'm going to just put it at 2.5.I'm going to put that into my simulation. I would do it at the beginning.That's when I've created the creature in the simulation.I just do this p.step-- Then I just need to tell itwhich physics engine it is. That's it.Then hopefully, if I just run the tests again,it won't crash because that's all good. Fine.I'm happy now.Other things that we might consider.I'm not going to go too much into this, but you could punish the creaturefor being too big.There's all kinds of other things we could put into the fitness function.We'll think more about those later.For now we're just going to say, it doesn't matter how big it is,how many motors it has, we're just going to let it tryand get as far as it possibly can. That's fine for now.In summary, we've just been building the fitness function.We've been thinking about what we're going to measure,which is the distance that the creatures traveled.Then we've worked through various stages to get that to work,and found various issues, and eventually implemented thatso that we can actually now calculate the fitnesses or the distance traveledby a whole population of creatures, which is setting us up readyto do the evolution.We also dealt with that flying into the air problem.We now drop the creature onto the ground, and it goes from there.In this video, we've just been implementingthe fitness function."
}