{
  "course": "DSM100-2022-OCT",
  "topic": "Topics 5&6: Creatures",
  "title": "Lecture: Creature class",
  "url": "https://learn.london.ac.uk/mod/page/view.php?id=96292&forceview=1",
  "transcript": "[music]-In this video,we're going to be starting out on the part of the codewhere we convert this expanded genome into an XML file.In summary, we're going to, first of all,look at some tweaks that I've had to make to the genome codejust to fine-tune it a little bit.Then we're going to dig into the creature class,which is the bit that's going to be doing the XML conversionby basically building a bigger wrapper around all the DNAand all the processes that are needed to convert that into XML.First of all, tweaks to the genome.Now, first of all,I think I mentioned at the end of the previous video,we had to add extra genome parameters to URDFLink.Let's have a look at those.I've got my code editor here.This is the updated version of the URDF link constructor.You can see that now it has all of the genome parametersfrom genome spec in there. I just added them all.You may have a different Python style, and that's totally fine,you might prefer to have a Kwargs dictionary coming in,and then to use a dictionary to store those.I prefer explicitly specifying every argument to the constructorjust because I find that clearer and more straightforward.I've done that, and then I assigned them all as variables inside the URDFLink.It's got all the data it needs for when we're goingto then convert it into XML later.Then in terms of the code that actually creates that,here's my genome to links code.You can see it's just adding more parameters to the constructor.Instead of just sending the parent in, and the name, and the recursion,it sends in all the other ones as well.That's what I've done there. That's the first tweak.The next tweak is setting the parent name on the root node to 'None'and a little bit of adjustment I've done on the code there.That's in the genome to links code.What you'll notice is how similarly, I've started out with empty links array,set the link index to 0, and set the parent names to that.The parent name starts out with just number 0 in,and then I set the link name using the link ID.I don't increment it yet.Then I select the parent, and then I set the parent name.What this means is the first time this loop iteration runs,they'll only be one parent availableand it will also be the only link available.It means the link is linking to itself,and that's a problembecause we can't have links linking to themselves.They always have to link to a different link.That's the way it works.What I've had to do is instead of adding every parent--Because I've already added the first parent ID,ID0 into the parent names.I only add them once the value of the ID is greater than 0.The first one is already in there, that means I don't get two 0parents in there.Because if I had two 0 parents in my available parents,it just increases the chance in a way that I don't want of the subsequent linksconnecting to that parent.Just because there's two of them in there says more likely to choose that one.That ensures there's only one instance of the root parent link in there.Then this code here allows me to set up the first link,which remember, it has to be the root link that doesn't link to anything.It's just going to be itself.That one is now having its parent name set to none so it won't linkto anything else.That's how I've tweaked that code just to make sure that I don't get 00,two 0 parents in there and y first link is always linked to noneso that it ensures that it works.I need you to do this because once we plug all this code into the genome,once we're actually pulling those numbers out of the genome,suddenly it becomes more complicated than what we had beforewhere we were parsing in test code like we were hard codingwhat the names of the links were, and therefore it was all working.Once you pull them out of the genome, it becomes a little bit more complicated.Those two tweaks.The other tweak I've done is that I realized that I wasn't gettingthe correct number. When I got on to the next step,which is doing the expanded links,I wasn't getting the correct number of links in my expanded links array.I'll show you that test in a minute.The trick was to set the recursion to greater than 0.The recursion has to be at least 1 because I foundthat I was basically scaling my recursion from 0 up to the maximum recursionallowed which meant that sometimes the recursion will be actually 0.That means if the recursion is 0,it would not even generate any children links off of that link,so it doesn't work properly.You have to have a recursion of at least one for the code to work.These are all things that got revealed to meas I went to the next step that we're going to go through nowand started coding that up.Let's just see where that is.You'll see that in the code where I create the link,the recursion level is now set to recursion +1.If it's 0 it will go up to 1.Is always at least 1 basically.That was the trick there.That's that.Next up, the creature class.We've got our genome class,which gives us all these capabilities.Most of them are static functions.So it's stateless, it allows us to work with DNA,basically but we need a higher-level stateful wrapperwhich is going to be the subject of our evolution if you like.We're going to call this a creature.It's basically going to be a wrapper class that stores some DNAand is able to call lower-level functions on the genometo turn that into URDF and so on.Let's start out building the creature class.The first thing I want to do is I'm going to create two new files.One is going to be called test_creature.Test_creature.I'm going to create another one, and this one's going to be calledcreature because I'm going to be coding up the creatureas its own thing.You see, I've now got test_creature, and I've got creature.Test_creature is going to be one of these unit tests.Import unittest and I define a class called TestCreature,which is going to test if she's expanding from unittest.Test.Oops, I didn't spell unittest right.unittest.TestCase like that.Let's define our first test.CreatureExists.All right. Just verify that we have a creature class.Let's import the creature file.The module rather.Self.assertIsNotNone(creature.Creature).We're just going to verify that this kind of creature constructor is NotNone.If I run that test,then it is going to fail.It's not going to do anything because I haven't called unittest.main.Let's just do that.Unittest.main.That will cause the test to run, run the code.Oh, interestingly, creature.Creature is not actually None.That's interesting.Is not None. Creature.Creature.Oh, because I forgot to prefix my test with the word test.Therefore, it didn't run that test.Let's run it again.Now it's failing.When you're using unittest,it basically looks at all of the functions you define.If they begin with the word test,then it will consider it to be a test and it will run it,but because I didn't prefix the world test it didn't work.Attribute module creature has no attribute creature.That's true because I haven't created it yet.Let's go ahead and instantiate that.I've just noticed that creature is there.There we go. creature.py.Let's define our class creature,and let's define that special constructor function,and it can just do nothing for now.Remember, minimum code to parse the test even if it's useless.We're parsing the test now.Now we write another test.What I want my creature to be able to do,this is where we get into actually specifyingwhat my creature is going to do.I want to basically be able to create a creatureand then it's going to generate a random genome for itself,and then it's going to be able to give me back a set of links from that.A set of the unexpanded links and the expanded links.Let's do that.I'm just going to kill my teams.I could potentially edit that bit out, but that's okay.def testCreatureGetFlatLinks.Let's just verify.This is a basic function I want to create.I want to basically create a creature and ask it to give me its flat_links.That means in order for it to do that, it's going to talk to the genome class,it's going to do bits and bobs and generate a random genome,and everything else.That's a way of just giving me a high-level thing that I want to do.c = Creature,and I'm going to give it a size.I'm going to say gene_count=4 because I want my creatureto have parameter where I can tell it how big the genome os going to be,so creature.Creature.Then one thing to do is verify that self, links = creature.get_flat_links.self.assertGreater--Let's get the auto the word assert.I want greater than,the length of the links must be greater than zero.In fact it should be equal. Let's do an assertion on equal.Because if I told it to have a gene count of four,the length of that should be four.Let's run that.You get an unexpected keyword argument gene count.That's the first error I need to fix.Which is, let's get rid of that and that,I don't want that or that, let's trim it down a bit.It's going to have to take a keyword argument first which is gene count.Here is where it gets interesting. We actually have to do some work now.Let's import the genome module.I'm going to say self.dna = genome.Genome.get_random_genome().Get random genome takes two parameters, gene_length which is a numberof parameters on each gene which I don't know yet.What I need to do is also get a spec,so self.spec = genome.Genome.get_gene_spec.I've got spec and the gene length is length of self.spec.Next up I need to code up.Let's see if we can-- yes that's okay,self.spec and then the number of genes is gene_count.I'm still not going to parse the test.Then the next thing is I need the function code get_flat_links.What get_flat_links is going to do,is it's going to convert the DNA into a set of flat_linksusing the genome functions.self.flat_links = genome.Genome.genome_to_links().genome_to_links just takes as it's arguments the gdicts.How do I get gdicts? gdicts = genome.Genome.genome_dicts().Then what does that take as an arguments? Hopefully just the DNA.Genome specs, so self.dna, self.spec.That should give me the genome dicts and then I can parsethat to the function here, gdicts.Really, it's just using all the stuff we've already builtbut just kind of giving me higher level of functions on itso that all the sort of house-keeping stuff we've to createDNA and all that's been done for me.Then eventually I can just return self.flat_links.Let's go over to the test code and see if that's working now.Okay, module of creature has no attribute get_flat_links.Does it really?Because it's c.get_flat_links, not creature.That test is parsing, good.It's successfully converting it's links into flat_links.Because I've written all these unit tests on genome,I can be reasonably confident it's doing what I think,it's not just doing some weird random stuff.That's the idea of building on these tests.You build up and up and up and if you're not sure if they're workingbecause you made some changes, you can always go back and rerun them.Regression testing.Next up, I've got my flat_links, what about expanded links?Okay, let's do a test for expanded linksand this is going to be a def testExpLinks.This one is going to do all the same stuff.Then I'm going to do exp_links = c.get_expanded_links.What I'm going to do this time is assert that,the length of expanded links.The length of expanded links needs to be equal or greaterthan the length of the regular links, which makes sense.If you remember how it works,we basically start out with these flat_linkswhere you've got one for every unique link and then we run the recursive expanderwhich then would at least generate the same number of links again.If the recursion of all of them is one, for example,but the expanded links will have the same numberas in the un-expanded links, but it's likely that one of themat least is going to have a recursion of greater than oneand therefore we'll end up with greater than.That comes down to the test which is that we need to self assert,it should be greater than or equal to the length of linksand length of expanded links, okay.Actually, if you remember earlier, I was saying how to make some tweaks.This is one of the tests that I failed earlier and had to go backand rework the genome code a little bit.Next I need to run that and obviously it failsbecause it doesn't have an actual record get expanded links.Let's go in and write get expanded links and look how clean my code is herebecause I'm writing these tests, I'm writing the minimum code to do that.get_expanded_links.First of all, I'm going to do self.get_flat_links,and then I'm going to doself.exp_links = genome.Genome.expandLinksand let's see what it takes.This is where it gets a little bit tricky.The expand links function needs a parent link, a unique parent name,and flat_links and expanded links.Actually, remember that that function doesn't really return,it just builds it out in this array.Expanded links is there and then the parent linkis going to be the first link of the flat_links, self.flat_links zero.That's the first parent.Then the parent name is going to be the name of thatin the first instance, .name.Next up we have the, flat-links array,so self.flat_links and then we havethe expanded links array which is exp_links.Then at the end what we can do is we can doself.exp _links = exp_linksand I can also return self.exp_links as well.So we got it.That way, by coding this function I generatethose expanded links and store them into the creature,so the creature is now stateful,so I'm not using those static method things anymore.The creature when we call get_flat_links and give you these flat_linksbut also generate them if it needs to.Which is possibly a bit naughty because then that means I've got functionsthat are doing two things.Maybe I should separate it and have one code generate flat_linksand get them or something like that.For now let's just leave at two, that's okay,let's not get super engineering on it.AssertionError, 4 is not greater than or equal to 10.Now I've got a problem there because actually--Sorry, I've got it the wrong way around.The expanded links should be at least as big as the regular links.I've got it the wrong way around, so let's run that.Great.Because of the random nature of this,when we're testing things that are randomly generated genomes,the test might parse but then next time round it generatesdifferent random numbers and it doesn't parse that time.What I sometimes do is I'll just run the test a lot of times, okay.For i in range (100),just run it 100 times.Literally, I just chucked it into a loopto run 100 times and then we can verify.Great, even if we run it 100 times it's not going wrongand I can even go really crazy and set the gene count to 25to maybe just verify even with a massive tier.It didn't even have to think about that one.That's 25 genes and we could even print out.I wonder how big these things are going to be.That's with a 25 genome so that means there's 25 different unique linksbut then we can have recursive parts of that tree.Many parts of the tree or graph could be recusing outinto massive sub branches.Let's see how big these things actually are, right.If we run it a 100 times and I'm just going to print outthe length of the expanded links just out of interest, like that.I've printed out the length of the expanded linksand then that would just give us an insight into this.You can see that from those numbers there,for example 1,710,you can see that I'm ending up with some pretty large robots herebecause remember it's recusing in and giving you that big subtree.You can get really complicated with recursion,you can get really complicated elaborate creatures very quicklywith very few genes in the genome.That's what's cool about this,but we probably don't want to be simulating creatures of that sizebecause it's just going to take too long, but we can have a look at them, certainly.That's good, right, where are we?We've just been preparing ourselves to actually do the big pushand generate the XML.We've created a creature classand we've added a couple of functions to it.Before we did that I had to do a few tweaks on the genome code,on that links code and the expanded links just to make surethat I was getting the correct names of thingsand everything was generating in the right sizes.Good we're now ready to get on with the XML generation.In this video we've just been preparing to generate XML."
}